<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: go | haya14busa]]></title>
  <link href="http://haya14busa.com/categories/go/atom.xml" rel="self"/>
  <link href="http://haya14busa.com/"/>
  <updated>2016-12-26T02:53:53+09:00</updated>
  <id>http://haya14busa.com/</id>
  <author>
    <name><![CDATA[haya14busa]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Go の CI で lint と カバレッジ回して非人間的なレビューは自動化しよう in 2016年]]></title>
    <link href="http://haya14busa.com/ci-for-go-in-end-of-2016/"/>
    <updated>2016-12-25T23:15:50+09:00</updated>
    <id>http://haya14busa.com/ci-for-go-in-end-of-2016</id>
    <content type="html"><![CDATA[<p>この記事は <a href="http://qiita.com/advent-calendar/2016/go3">Go (その3) Advent Calendar 2016</a> の24日目の記事です(代打)．
メリークリスマス!</p>

<p>本記事では Go 言語プロジェクトの CI で回すと便利な各種lintの紹介やカバレッジ計測の方法などなどについて紹介します．</p>

<h2>Go 言語おすすめ linter</h2>

<p>Go の lint 一覧といえば <a href="https://github.com/alecthomas/gometalinter">gometalinter</a> じゃん?
みたいな話もあると思うのですが，CIで回すには個別に linter を明示的に回すほうが良いかと思います．
ということで 僕が普段使ってるオススメ linter の紹介です．</p>

<h3>go vet</h3>

<ul>
<li><a href="https://golang.org/cmd/vet/">vet - The Go Programming Language</a></li>
<li>おすすめ度: ★★★★★</li>
</ul>


<blockquote><p>Vet examines Go source code and reports suspicious constructs, such as Printf
calls whose arguments do not align with the format string. Vet uses
heuristics that do not guarantee all reports are genuine problems, but it can
find errors not caught by the compilers.</p></blockquote>

<p>Go 言語標準でついているlintツールで，コンパイラが検出しないエラーを検出できます．
false positive な結果も無いようにデザインされているのでエラーがリポートされた場合は安心してCIをfailにできます．
go vet に検出されたエラーはほぼ100%直したほうがよいでしょう．</p>

<h3>golint</h3>

<ul>
<li><a href="https://github.com/golang/lint">golang/lint: This is a linter for Go source code.</a></li>
<li>おすすめ度: ★★★★☆</li>
</ul>


<blockquote><p>Golint differs from gofmt. Gofmt reformats Go source code, whereas golint prints out style mistakes.
Golint differs from govet. Govet is concerned with correctness, whereas golint is concerned with coding style.</p></blockquote>

<p>gofmtがコードのリフォーマットを，govetがコードの正確性をチェックするのに対して，golint
は Go のソースコードの <strong>&ldquo;コーディングスタイル&rdquo;</strong>
の問題を報告します．これはエラーというよりも &ldquo;suggestion&rdquo; に近く，
基本的に従っていたほうがGoの慣習に沿った確実によいコードになるのですが，
まれに，いやここの関数はコメント書かなくても絶対いいよね&hellip;とかいうケースもあり
若干消耗することもあるので星4です．</p>

<p>なお，結局はコーディングスタイルの問題をリポートするという思想からデフォルトでは問題があっても
exit code は 0 になるので，落としたい場合は <code>-set_exit_status</code> flag を付けましょう．</p>

<h3>errcheck</h3>

<ul>
<li><a href="https://github.com/kisielk/errcheck">kisielk/errcheck: errcheck checks that you checked errors.</a></li>
<li>おすすめ度: ★★★☆☆</li>
</ul>


<p>errcheck は関数のエラーの返り値をハンドリングチェックしているかどうかを静的に解析してくれるツールです．
エラーを捨てた状態の場合思わぬ動作(nilになってたりだとか)するので，これをチェックしてくれるのは大変嬉しいです．</p>

<p>ただし，少し実際直さなくてもいいという意味でのfalse positive が多くCIで動かすには工夫が必要で星3です．エラーをチェックしてくれるという便利度は満点．
なお，最近は標準ライブラリで必ずエラーがnilとして返ってくるような関数についてはリポートしないという
false positive を減らす工夫もされているようです．</p>

<h3>staticcheck</h3>

<ul>
<li><a href="https://github.com/dominikh/go-staticcheck">dominikh/go-staticcheck: Staticcheck is go vet on steroids, applying a ton of static analysis checks you might be used to from tools like ReSharper for C#</a></li>
<li>おすすめ度: ★★★★★</li>
</ul>


<p>staticcheck は一言で言うとサードパーティーの <code>go vet</code>です．go vet でチェックされていないようなことを静的に解析してくれます．
(例えば正規表現がvalidかチェックしてくれるかなどなど&hellip;たくさん項目があるのでREADMEを見てみてください．)</p>

<p>作者の <a href="https://github.com/dominikh">dominikh さん</a> は Go
言語の開発にも関わっていて，dominikh さん製Go lint ツールは個人的には
信頼できる印象です．github/go の issue でも  go vet のissueなどに， staticcheck
は実際こういうのチェックしてるけどと言った感じで参照されてたりするのを見かけます．</p>

<p>そして次の2つのツールも dominikh さん製です．</p>

<h3>gosimple</h3>

<ul>
<li><a href="https://github.com/dominikh/go-simple">dominikh/go-simple: Gosimple is a linter for Go source code that specialises on simplifying code</a></li>
<li>おすすめ度: ★★★★★</li>
</ul>


<p>gosimple は一言で言うとdominikh さん製のサードパーティー <code>gofmt -s</code> です．もっとコードをシンプルに出来るところを報告してくれます．
(ただし執筆時現在，自動で修正してくれるオプションとかはない)</p>

<p>例えば <code>if err != nil { return err }; return nil</code> といった構造のコードがあれば
<code>return err</code> で十分だよ? と報告してくれます．</p>

<p>報告に false positive もない印象で，あーそんなメソッドあったのか〜ということに気付いたりできてオススメです．</p>

<h3>go-unused</h3>

<ul>
<li><a href="https://github.com/dominikh/go-unused">dominikh/go-unused: Check Go programs for unused identifiers</a></li>
<li>おすすめ度: ★★★★★</li>
</ul>


<p>使ってない identifier をチェックしてくれます．
Go のコンパイラ自体が使ってない変数があるとコンパイル通らないという話もありますが，
unused は グローバル変数の var や const, struct の field，export されていない関数などで
使われていないものを報告してくれます．</p>

<p>報告してくれないのは使われてない関数の引数くらいでしょうか? これはインターフェースを満たすための関数など，
引数もらうけど使わないんやというケースなどを考えて報告されていないのではないかという気がします．[要出典]</p>

<p>また個人的には使えてないので強くオススメできませんが，パッケージのリストを渡して
exported なもので，渡したパッケージ内で使われていないものをチェック出来る機能もあります．
<a href="https://github.com/dominikh/go-unused#whole-program-analysis">https://github.com/dominikh/go-unused#whole-program-analysis</a>
&ldquo;internal&rdquo; packages などを使っていたりする場合は便利かもしれないですね．</p>

<p>unused は個人的には大変便利に使っていて，ごくまれにデバック用のexportしてない関数を報告されて，
あー&hellip;ってなる以外に false positive な結果もなく便利に使っています．</p>

<p>この前 interface を満たすためのダミーの関数をいろんな struct に定義してたんですが，
その際，追加すべきでない struct にも追加してしまい，それを unused が<a href="https://github.com/haya14busa/go-vimlparser/pull/23#pullrequestreview-11276693">報告</a>
してくれたことがありました．インターフェースを満たすかどうかといった観点での&#8221;used&#8221;もちゃんと見てくれていて大変良い子だな〜と思い感動しました．
オススメです．</p>

<h3>gofmt -s</h3>

<ul>
<li><a href="https://golang.org/cmd/gofmt/">gofmt - The Go Programming Language</a></li>
<li>おすすめ度: ★★★★☆</li>
</ul>


<p>linter ではない若干番外編その1．</p>

<p><code>gofmt -s</code> の結果 diff があるかどうか，つまりもっとシンプルにかけた部分がないかということをチェックできます．</p>

<p>コマンド: <code>(! gofmt -s -d . | grep '^')</code></p>

<p>括弧は travis などのyamlでvalidなものにするために使っています．
gofmt も exit code が 1 になったりすることはないので個人的には <code>grep '^'</code>
の結果を否定することによって，diffを表示しつつ，diffがあればfailにするという手法を使っています．
(<code>xargs -r</code> とかはMacでは<code>-r</code>がないとかがある&hellip;)</p>

<p>基本的にGo言語開発時はみんな gofmt かけていると思いますが，<code>-s</code> は付けていなかったり，
<code>goimport</code> で <code>gofmt</code> を代用していた場合に <code>-s</code> オプションがなくてかけてなかったりするので
CI で実行するとちょっと便利です．</p>

<p>ちょっと便利なんですが，<code>-s</code> つけるとめっちゃシンプルになって絶対いいよね&hellip;! というよりは，
あー手元で実行してなくて，CIサーバでdiffでちゃったよ&hellip;直すか&hellip;とちょ〜っとだけ消耗することが
あるという意味で個人的にはオススメ度星4です．(goimport <code>-s</code>フラグ足してくれ〜)</p>

<h3>go test -race</h3>

<ul>
<li>おすすめ度: ★★★★★</li>
</ul>


<p>linter ではない若干番外編その2．
<code>go test</code> に <code>-race</code> を付けるとrace condition があるかチェックしてくれます．
特に goroutine とか使ってるコードであれば，CIでのテスト実行時にはぜひ付けておくべきでしょう．
僕も何度も<code>-race</code>に怒られてコード直したり，ああここlockいるなと気付かされております．</p>

<h3>その他</h3>

<p>あんまり僕がまだ使えてなくて，ちゃんとオススメできないけど便利な静的チェックツールはいくつかあります．</p>

<h4>interfacer</h4>

<ul>
<li><a href="https://github.com/mvdan/interfacer">https://github.com/mvdan/interfacer</a></li>
<li>引数の型とかインターフェースでいいじゃん?というところを指摘してくれる. e.g. <code>*os.File</code> -> <code>io.Reader</code></li>
<li>個人的にはインターフェースにするといいところは最初からインターフェース使ってたりするしそこまでの恩恵は感じない</li>
</ul>


<h4>gosum</h4>

<ul>
<li><a href="https://github.com/haya14busa/gosum">https://github.com/haya14busa/gosum</a></li>
<li>急に拙作ツールの宣伝(?)</li>
<li>Go のインターフェースで直和型っぽいことを表現したときの，type switch に抜け漏れがないかを静的にチェックするツールです．</li>
<li>Scala でいう sealed trait のパターンマッチでコンパイラが抜け漏れがあると warning だしてくれるというやつのGoバージョン</li>
<li>詳しくはこの記事に書きました ->  <a href="https://medium.com/@haya14busa/sum-union-variant-type-in-go-and-static-check-tool-of-switch-case-handling-3bfc61618b1e#.lh90e9kx1">Sum/Union/Variant Type in Go and Static Check Tool of switch-case handling – Medium</a></li>
<li>書いてみて，使ってみて実際便利だと思ってるんですが，まだちゃんとCIで回したりはしてないので，その他枠で雑に紹介です．</li>
</ul>


<p>ところで linter 書くときって，AST ベースで解析するツールが僕の観測範囲では多いと思うですが，
Goは必要であれば <a href="https://golang.org/pkg/go/types/">go/types</a> パッケージを使って型情報まで使って
解析できるので大変便利ですね&hellip;! 標準ライブラリでカバーされてるところも +1</p>

<p><strong>&ldquo;go/ast ではしゃいでるのはもう古い! 時代は go/types !&rdquo;</strong> みたいな煽りタイトルの解説記事を最近は待ち望んでます．
go/types 関連は標準ライブラリの中でもかなり大きいものなのでなかなか僕もまだ全貌を理解できてないです．</p>

<h4>その他のその他</h4>

<p><a href="https://github.com/alecthomas/gometalinter">gometalinter</a> とか <a href="https://goreportcard.com/report/github.com/haya14busa/reviewdog">Go Report Card</a> で紹介されているツール．</p>

<p><a href="https://github.com/fzipp/gocyclo">https://github.com/fzipp/gocyclo</a>
とかイマイチ恩恵を受けたことがないんですが，gometalinter とか <a href="https://goreportcard.com/report/github.com/haya14busa/reviewdog">Go Report Card</a>
で使われているツールは参考になるかもしれません．</p>

<h2>reviewdog: linter の false positive と闘う</h2>

<p>特に golint や errcheck など，上記でオススメしたlinterの中には，false positive
なリポートが結構あって，めっちゃ便利でチェックしたいんだけど CI で fail
にしづらい&hellip; というものがいくつかあります．</p>

<p>そこで拙作ツール <a href="https://github.com/haya14busa/reviewdog">reviewdog</a> の紹介です．(宣伝)</p>

<p>もちろん Go 製です!</p>

<p><a href="https://github.com/haya14busa/reviewdog/pull/63#pullrequestreview-13287340"><img src="../images/post/2016-12-26-reviewdog.png" alt="" /></a></p>

<p>(画像は実際のPull Requestのコメントへのリンクになってます)</p>

<p>reviewdog は Go 言語の linter に限らず，任意のコマンドの結果を&#8217;errorformat&#8217;
という形式を使うことでパースして，<em>diff</em> で新たに追加された部分にたいする問題だけを
表示したり，GitHub にコメントすることが出来るツールです． 詳しくは -> <a href="http://haya14busa.com/reviewdog/">reviewdog を飼ってコードレビューや開発を改善しませんか - haya14busa</a></p>

<p>結果をdiffでフィルターすれば，それらの問題についてのみPull
Requestのレビュー時やコミット時にチェックすることが出来るので，
もし false positive な結果な場合は単に無視すれば次回以降に同じ問題は報告されません．</p>

<p>もちろん，例えば先に紹介した unused などは全然diffと関係ない部分で新たに問題がおきたりすることもあり，
結果を diff でフィルターするというのはfalse positiveと闘う銀の弾丸ではないのですが，
多くの場合これで十分機能を果たすでしょう．
(一応 diff 外の問題もうまくまとめて報告する仕組みも足したいな〜という気持ちはあります)</p>

<p>Go 製ツールである reviewdog は自分自身のコードでドックフーディングしていて，この記事で紹介した
いろんなGo 用 linter を実行していて，上記の画像のように実際に便利に使っています．
参考: <a href="https://github.com/haya14busa/reviewdog/blob/08050fc886b39f7caa4b0f39bcb2188043030214/reviewdog.yml">reviewdog/reviewdog.yml</a>
(最近はyamlでも管理できるようにしていて，より簡単にローカルで実行したり，git hook で実行しやすくしたりしたいなどと改善しています)</p>

<h2>Goのテストカバレッジをレビューでも活用する</h2>

<p>Go は標準で <code>go test -coverprofile=coverage.out .</code> などと実行するとテストカバレッジを取得することができます．
ただ実は CI などでカバレッジを取得する際は注意点があり，複数のパッケージをまとめてカバレッジを計測することはできません．
つまり例えば <code>go test -coverprofile=coverage.out ./...</code> とはできません．これは
<code>go test</code> 内部ではパッケージごとにテスト実行用バイナリを作成してそれぞれ実行してるという設計になっていることに起因します．
<a href="https://github.com/golang/go/issues/6909#issuecomment-233493644">issue</a> は上がってますが標準では対応するのはなかなか骨が折れそうです．
(ちょっと修正してコントリビューションしてみようかと格闘しましたが構造的に地味に大変そうでした&hellip;)</p>

<p>そこで現状で，複数パッケージのテストカバレッジに対応するために色んな所で Makefile やGoのツールを使うといった解決方法が紹介されています．
しかし!紹介されていて，確かにある程度はどれも動くのですが，実は多くのスクリプトはちょっと片手落ちなものになっています．
例えば go test の <code>-coverpkg</code> 引数を使わないと依存先のコードカバレッジが取得できてなかったり，
結果の coverage.out に重複行が生まれるケースがあったりします．</p>

<h3>解決策</h3>

<p>mattn さんの <a href="https://github.com/mattn/goveralls">mattn/goveralls</a>
では上記の問題に対応したマルチパッケージ対応テストカバレッジ機能が備わっています．というか僕がPull Request しました．
<a href="https://coveralls.io/">Coveralls</a> に投稿する場合は goveralls を使うと良いと思います.  (<code>goveralls -service=travis-ci</code> でよしなにやってくれる)</p>

<h3>ローカルでは?</h3>

<p>goveralls にコントリビューションしたあと，あれ&hellip;これローカルでもやりたいじゃん&hellip;ということに気付き，
既存のMakefileソリューションや似たツールはいくつかあるにはあったんですが，上記の問題などの対応とか
いろいろ面倒だったのでマルチパッケージカバレッジ作成用go test のラッパーツールを作りました．</p>

<p><a href="https://github.com/haya14busa/goverage">haya14busa/goverage: go test -coverprofile for multiple packages</a></p>

<pre><code>$ goverage -coverprofile=coverage.out ./...
</code></pre>

<p>とかするといい感じに coverage.out が生成されます．便利．</p>

<h3>codecov に投稿してレビューでも活用する - &ldquo;おい、coverall もいいけど codecov 使えよ&rdquo;</h3>

<p>サブタイは <a href="https://twitter.com/b4b4r07">b4b4r07</a> さんリスペクトです． ref: <a href="http://qiita.com/b4b4r07/items/9e1bbffb1be70b6ce033">おい、peco もいいけど fzf 使えよ - Qiita</a></p>

<p><a href="https://codecov.io/">Codecov</a> という <a href="https://coveralls.io/">Coveralls</a> と似たサービスがあるのはご存知でしょうか?
僕は以前からたまに見かけたことはあったのですが，最近はじめて使ってみて，断然 coverall よりいいじゃん&hellip;!!! と感じました．</p>

<p>全体的に洗練されてる&hellip;というよさもあるんですが，一番いいところは Pull Request の diff に対するカバレッジを表示できて，
ブラウザの拡張をインストールすれば GitHub の Pull Request 画面上でカバーされた行をオーバーレイで確認できるところが大変気に入りました．</p>

<p><a href="https://github.com/haya14busa/reviewdog/pull/63#pullrequestreview-13287340"><img src="../images/post/2016-12-26-codecov-pull-request.png" alt="" /></a></p>

<p>もちろん Codecov 上のページでも見れます: <a href="https://codecov.io/gh/haya14busa/reviewdog/pull/63/compare">Compare ⋅ haya14busa/reviewdog</a></p>

<p>Go 言語リポジトリのカバレッジを travis で計測して codecov へ投稿する例:</p>

<pre><code># .travis.yml
install:
  - go get github.com/haya14busa/goverage

script:
  - goverage -coverprofile=coverage.txt ./...

after_success:
  - goveralls -service=travis-ci -coverprofile=coverage.txt
  - bash &lt;(curl -s https://codecov.io/bash)
</code></pre>

<p><a href="https://github.com/codecov/example-go#caveat-multiple-files">codecov 公式のGo言語用リポジトリの例</a> では Makefile を使ってますが，
完全に上記のマルチパッケージサポートの問題を踏んでるので <code>goverage</code> を使うと良いと思います．</p>

<p>テストカバレッジは別に100%を目指さなくてもよいと思っていて，全体のカバレッジが何％以下とか何％下がったらステータスをfail
にするといった機能がcoverallやcodecov にはありますが，この辺を有効にすると結構消耗するかと思います．</p>

<p>ただ，カバレッジを参考にすることは有用だし，ユニットテストが基本的に書くべきで，
Pull Request などではカバーすべきところをしっかりカバーしたテストを足したいし，
レビュー時にもそのあたりが可視化されると大変便利です．</p>

<p>僕はたまに Go のレビューするときは手元でテストまわしてcoverageみて，ここテストそもそも無いから足して欲しいだとか，
この行はカバーされてないけど，カバーすべき部分なのでテストケース足して欲しいとか言ったりするんですが，
codecov を使うとこのフローがやりやすいし，レビュイーもPull Request を出した時点で自分で気付いて
テスト足したりできると思います．</p>

<p>実は codecov 使い始めたのは最近で，僕自身がチーム開発として使った経験はまだないのですが，
coverall よりも codecov 使うとこの辺いい感じに可視化されて人間が指摘しなくてもよくなったり，
レビュワーとして指摘しやすくなったりすると思います．</p>

<p>せっかく Go という言語は標準でテストが書きやすく，カバレッジ計測もしやすいので，ぜひ皆さんもカバレッジを計測して，codecov 使ってみてはいかがでしょうか?</p>

<h3>まとめ</h3>

<p>Go のCIでまわすと便利なlintツールを紹介したり，テストカバレッジの取得方や codecov のオススメなどをしました．
Go は <code>go/ast</code>, <code>go/types</code> など <code>go/</code> 下の標準パッケージを使ってコードをパースしてASTを取得したり，型情報を取得したりなど
するライブラリが用意されているので，必要に応じて自前でチェックツールを作ったりもしやすく面白いです．</p>

<p>この記事で紹介したものは，一般的に多く使われているみなさんが知っているようなものから，あまり知られてないものまであるかと思いますが，
すべて少なくとも僕が使っていて便利だなぁ〜，と思ったものを紹介してみました．
他に便利なオススメツールなどがあれば教えてください！</p>

<p>個人OSSプロジェクトではレビュワー最初はいない問題などがあり，最近はPull Requestを開いてlint チェックさせたり，カバレッジみたり，
改めてブラウザ画面上でセルフレビューするなどしていて，まぁちょっと面倒もあるけど良い感じです．
あとは設計レビューとかもしてくれるGoのツールがあればカンペキですね〜〜〜！！！１</p>

<p>もちろんチーム開発でのレビューでも，消耗しがちな非人間的な指摘は機械にやってもらって，
もっと大事な観点をレビューするために，この記事で各種紹介した手法は役に立つかなと思います．</p>

<p>来年も Go 書いていくぞ!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go で Vim プラグインを書く]]></title>
    <link href="http://haya14busa.com/vim-go-client/"/>
    <updated>2016-12-21T18:14:54+09:00</updated>
    <id>http://haya14busa.com/vim-go-client</id>
    <content type="html"><![CDATA[<p>この記事は <a href="http://qiita.com/advent-calendar/2016/vim">Vim アドベントカレンダー 2016</a> の21日目の記事です．</p>

<p>最近は Go 言語が大好きすぎて，Vim plugin も Go で書きたい!!! という欲が出てきたので，
Vim plugin を Go で書く方法について紹介します．</p>

<h2>Go で Vim plugin を書くとは?</h2>

<p>一口に Go で Vim plugin を書くといっても</p>

<ol>
<li>Go で書いたバイナリがメインで Vim script の autoload 関数などから呼ぶ．例: <a href="https://github.com/mattn/vim-filewatcher">https://github.com/mattn/vim-filewatcher</a></li>
<li>Go 側からも Vim script を呼ぶ，つまり Vim script で Vim の情報を取得するところなど含めて，ほぼ全部 Go で書く．</li>
</ol>


<p>という 2 段階があると思います．本記事では2の方法も含めて紹介しますがまずは1から行きましょう．</p>

<h2>1. Go で書いたバイナリをつかった Vim plugin の作り方</h2>

<p>これは先程例にあげた <a href="https://github.com/mattn/vim-filewatcher">https://github.com/mattn/vim-filewatcher</a> がシンプルでわかりやすいです．</p>

<p><a href="https://github.com/mattn/vim-filewatcher/blob/22594895e16cb4de11afa37f04d88a996f48da58/filewatcher/filewatcher.go">filewatcher/filewatcher.go</a>
で書いた Go をインストール時に <code>cd filewatcher &amp;&amp; go get -d &amp;&amp; go build</code> でビルドし，
<a href="https://github.com/mattn/vim-filewatcher/blob/22594895e16cb4de11afa37f04d88a996f48da58/autoload/filewatcher.vim">autoload/filewatcher.vim</a>
でこのバイナリを <code>job</code> をつかって呼んでいます．</p>

<p><code>go get -d</code> を呼ぶことで依存するパッケージをダウンロードし，<code>go build</code> することで <code>$GOBIN</code> などを汚さずにプラグインディレクトリにバイナリを配置できます．</p>

<h4><a href="https://github.com/mattn/vim-filewatcher/blob/22594895e16cb4de11afa37f04d88a996f48da58/autoload/filewatcher.vim">autoload/filewatcher.vim</a></h4>

<pre><code>let s:cmd = expand('&lt;sfile&gt;:h:h:gs!\\!/!') . '/filewatcher/filewatcher' . (has('win32') ? '.exe' : '')
if !filereadable(s:cmd)
  finish
endif

function! filewatcher#watch(dir, cb)
  return {'dir': a:dir, 'job': job_start([s:cmd, a:dir], { 'out_cb': a:cb, 'out_mode': 'nl' })}
endfunction
</code></pre>

<p>バイナリを呼んでいるVim script もとてもシンプルで， windows かどうか見ながらバイナリのパスを取得し，
それを <code>job</code> で呼ぶだけです．簡単．プラグインの性質によっては <code>job</code> ではなく <code>system()</code> などを使ってもよいでしょう．</p>

<p>また，開発時には <code>g:plugin_name#debug</code> などを作ってそれを見て <code>go run</code> を呼ぶというふうに変えることもできます．</p>

<pre><code>function! s:separator() abort
  return fnamemodify('.', ':p')[-1 :]
endfunction

let s:is_windows = has('win16') || has('win32') || has('win64') || has('win95')

let s:base = expand('&lt;sfile&gt;:p:h:h')
let s:basecmd = s:base . s:separator() . fnamemodify(s:base, ':t')
let s:cmd = s:basecmd . (s:is_windows ? '.exe' : '')

if g:plugin_name#debug
  let s:cmd = ['go', 'run', s:basecmd . '.go']
elseif !filereadable(s:cmd)
  call system(printf('cd %s &amp;&amp; go get -d &amp;&amp; go build', s:base))
endif
</code></pre>

<p>僕が作ったプラグインから引っ張ってきた例で autoload/filewatcher.vim ほどシンプルではないですが，もうちょっとなんとか出来るかもしれないですね．
main パッケージのファイル (<code>s:basecmd . '.go'</code>) を1ファイルにすると<code>go run</code>で呼びやすいです．</p>

<h2>2. Go 側からも Vim script を呼ぶ必要があるようなプラグインの作り方</h2>

<p>mattn/filewatcher ではファイルの変更を検知してstdout にJSONを吐いて，それが job の callback に渡されるという形式で単体で簡潔してましたが，
場合によっては Go 側から Vim の状態を取得したり，Vim script を呼んだりしたい場合もあります．
そういうプラグインを作るには，job を JSON モードで起動し， <a href="http://vim-jp.org/vimdoc-ja/channel.html#channel-commands">:h channel-commands</a>
を使うことによって実現できます．</p>

<h4><a href="http://vim-jp.org/vimdoc-ja/channel.html#channel-commands">:h channel-commands</a></h4>

<pre><code>JSON チャンネルを使用すると、サーバープロセス側はVimへコマンドを送信できます。
そのコマンドはチャンネルのハンドラーを介さずに、Vimの内部で実行されます。

実行可能なコマンドは以下のとおりです:           *E903* *E904* *E905*
    ["redraw", {forced}]
    ["ex",     {Ex コマンド}]
    ["normal", {ノーマルモードコマンド}]
    ["eval",   {式}, {数値}]
    ["expr",   {式}]
    ["call",   {func name}, {argument list}, {number}]
    ["call",   {func name}, {argument list}]
</code></pre>

<p><code>{数値}</code>(<code>{number}</code>) は id で，job -> Vim に渡すさいはマイナスを指定する必要があり，
その渡した id と共に評価された値が返ってきます．</p>

<p>例えば Go 側で stdout に <code>["expr","line('$')", -2]</code> を書き込むと， Vim
が<code>line('$')</code> を評価してその結果が stdin に <code>[-2, "last line"]</code>
といった結果が返ってきます．</p>

<p>便利すぎる&hellip;</p>

<p>ということでidの取扱などこのあたりの処理を毎回丁寧にやるのは面倒くさいので，
<a href="https://github.com/haya14busa/vim-go-client">https://github.com/haya14busa/vim-go-client</a> というラッパーを作りました．
ドキュメント: <a href="https://godoc.org/github.com/haya14busa/vim-go-client#Client">https://godoc.org/github.com/haya14busa/vim-go-client#Client</a></p>

<p><a href="https://godoc.org/github.com/haya14busa/vim-go-client#Client"><code>type Client</code></a> が上記の channel-commands などのに相当するメソッドを持っており，
<a href="https://godoc.org/github.com/haya14busa/vim-go-client#Handler"><code>type Handler</code></a> がメッセージの受け渡しを担当します．</p>

<p>サンプル: <a href="https://github.com/haya14busa/vim-go-client/blob/32a96bf256fabc81dff549a70328a6bb3f24e9b5/_example/dev/job/job.go"><code>_example/dev/job/job.go</code></a></p>

<pre><code>package main

import (
    "fmt"
    "log"
    "os"
    "time"

    vim "github.com/haya14busa/vim-go-client"
)

type myHandler struct{}

func (h *myHandler) Serve(cli *vim.Client, msg *vim.Message) {
    log.Printf("receive: %#v", msg)
    if msg.MsgID &gt; 0 {

        if msg.Body == "hi" {
            cli.Send(&amp;vim.Message{
                MsgID: msg.MsgID,
                Body:  "hi how are you?",
            })
        } else {
            start := time.Now()
            log.Println(cli.Expr("eval(join(range(10), '+'))"))
            log.Printf("cli.Expr: finished in %v", time.Now().Sub(start))
        }

    }
}

func main() {
    handler := &amp;myHandler{}
    cli := vim.NewClient(vim.NewReadWriter(os.Stdin, os.Stdout), handler)
    done := make(chan error, 1)
    go func() {
        done &lt;- cli.Start()
    }()

    cli.Ex("echom 'hi'")
    log.Println(cli.Expr("1+1"))

    select {
    case err := &lt;-done:
        fmt.Printf("exit with error: %v\n", err)
        fmt.Println("bye;)")
    }
}
</code></pre>

<p><code>handler := &amp;myHandler{}</code> でハンドラを作って <code>cli := vim.NewClient(vim.NewReadWriter(os.Stdin, os.Stdout), handler)</code>
で stdin/stdout を介してVim と通信できるclientを作成しています．
あとはこいつを <code>cli.Start()</code> しておけば Vim から <code>ch_sendexpr()</code> などが呼ばれると handler に中身が渡されるし，
<code>cli.Ex("echom 'hi'")</code> などを呼ぶと Vim 側で <code>echom 'hi'</code> が実行されます．</p>

<h2>実例: vim-stacktrace</h2>

<p>実際に vim-go-client を使ってひとつプラグインを書いてみました．</p>

<p><a href="https://github.com/haya14busa/vim-stacktrace">haya14busa/vim-stacktrace</a></p>

<p><img src="https://raw.githubusercontent.com/haya14busa/i/e7ef65e590e850ea37425c6ebf4479c1422ef8c8/vim-stacktrace/stacktracefromhist.gif" alt="stacktracefromhist.gif (1287×800)" /></p>

<p>Vim のスタックトレースをquickfix に流し込むプラグインでやっていることとしては6日目の記事の <a href="http://qiita.com/tmsanrinsha/items/0787352360997c387e84">Vim scriptのエラーメッセージをパースしてquickfixに表示する - Qiita</a>
と近いです．</p>

<p>autoload 関数からjobに <code>ch_evalexpr</code>
する部分([link]<a href="https://github.com/haya14busa/vim-stacktrace/blob/933f9d10c7ef99467c27609fcdd80be37c0712e8/autoload/stacktrace.vim#L12-L30">https://github.com/haya14busa/vim-stacktrace/blob/933f9d10c7ef99467c27609fcdd80be37c0712e8/autoload/stacktrace.vim#L12-L30</a>())
を除いてほぼ全てがGoで実装されていて，現時点で Go の割合が 87.8 % です．</p>

<p><img src="https://cloud.githubusercontent.com/assets/3797062/21386073/5e56a5aa-c7b4-11e6-9cac-869cbb8ffe8d.png" alt="image" /></p>

<p>実装の中身としても，Vim のスタックトレースからは関数内における行番号しかとれず，ファイルの行番号が取得できない問題があるのですが，
それをGoで実装したVim script parser (<a href="https://github.com/haya14busa/go-vimlparser">https://github.com/haya14busa/go-vimlparser</a>) を使ってファイルをパースし，行番号を取得することができています．
また，<code>:CStacktraceFromhist</code> などは Vim script の <code>inputlist</code> をGo側から呼んでいてインテラクティブにVimと協調して動作できることも示せました．</p>

<h2>Go で書くよさ</h2>

<p>実際に Vim script でやっているひともいたように，vim-stacktrace は Go
が無いとかけなかったといった類のものではないですが，Goで書くといいことがたくさんありました．</p>

<ul>
<li>型がある安心感</li>
<li>テストが標準に備わっていて書きやすい (go test)</li>
<li>カバレッジも取れる! (go test -coverprofile)</li>
<li>Go のパッケージが使える (go-vimlparser, etc&hellip;)</li>
<li>etc&hellip;</li>
</ul>


<p>カバレッジなどは現在Vim scriptのテスティングフレームワークではサポートされていないし，なかなか実装しようとしてもムズカシそうなのですが，
Goでかけば標準でついてきます．とても便利．</p>

<p>coverall も使えます: <a href="https://coveralls.io/github/haya14busa/vim-stacktrace?branch=master"><img src="https://coveralls.io/repos/github/haya14busa/vim-stacktrace/badge.svg?branch=master" alt="Coverage Status" /></a></p>

<p>逆にPure Vim script と比較して悪いところや注意点があるとすれば</p>

<ul>
<li>vim-go-client がまだ安定してない</li>
<li>channel-commands がエラーをちゃんと返してくれない(エラーがあれば &ldquo;ERROR&rdquo; とだけ返ってくる)</li>
<li>チャンネルの通信で少しだけオーバーヘッドがある</li>
<li>現状vim/neovimに両対応できない</li>
</ul>


<p>といった感じでしょうか．もうちょっとvim-go-client精錬させたいですね&hellip;頑張ります&hellip;</p>

<h2>NeoVim のリモートプラグイン</h2>

<p>neovim 向けには実は <a href="https://github.com/neovim/go-client">neovim/go-client</a> というものが存在し，リモートプラグインをGoで書くことが出来るようです．</p>

<p><a href="http://vimconf.vim-jp.org/2016/">Vimconf 2016</a> で <a href="https://github.com/zchee">zchee</a> さんが発表していた nvim-go はこれが使われています．</p>

<p>スライド該当部分: <a href="http://go-talks.appspot.com/github.com/zchee/talks/vimconf2016.slide#33">http://go-talks.appspot.com/github.com/zchee/talks/vimconf2016.slide#33</a></p>

<p>正直なところ neovim のリモートプラグインの先行アドバンテージ(?)は大きく，vim-go-client と比較してかなり高機能になってます．
理想としては Vim 8 でも neovim でも使えるものをかけるようにしたいのですが， neovimのリモートプラグインが高機能であることや，
msgpack 依存であることからなかなか両方に対応することはムズカシイです&hellip;</p>

<p>うまく抽象化してロジックの部分だけ共通化して，vim8用/neovim用にメッセージのハンドラを管理してうんたん&hellip;みたいなことは出来るかも知れないので，
今後の研究課題という感じですね．あと僕がほとんどneovim使わないので nvim-go の仕様感とか知っている方はお話してくれると嬉しいです．
(Vimconf で zchee さんとその話ができたのは便利だった&hellip;)</p>

<h2>おわりに</h2>

<p>正直まだまだGoで書かれたVim plugin は少なく発展途上ですが，実用的なプラグインを作成することもできたので，可能性を感じます．
Go でかけばマルチプラットフォームに対応できるし，ライブラリがどうとか環境がどうとか気にすることなく動かせるので，Vim との親和性はかなり高いと思っています．</p>

<p>何よりGoはかわいい!書いていて楽しい!</p>

<p>まだまだ発展途上ですが，ぜひ皆さんもGoでVim プラグインを作ってみてください．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golangにおけるinterfaceをつかったテストで mock を書く技法]]></title>
    <link href="http://haya14busa.com/golang-how-to-write-mock-of-interface-for-testing/"/>
    <updated>2016-11-02T07:19:14+09:00</updated>
    <id>http://haya14busa.com/golang-how-to-write-mock-of-interface-for-testing</id>
    <content type="html"><![CDATA[<p>いい記事に感化されて僕も何か書きたくなった。</p>

<p><a href="http://deeeet.com/writing/2016/10/25/go-interface-testing/">Golangにおけるinterfaceをつかったテスト技法 | SOTA</a></p>

<p>リスペクト:</p>

<ul>
<li><a href="http://mattn.kaoriya.net/software/lang/go/20161025113154.htm">Big Sky :: golang で終了を確認するテストの書き方</a></li>
<li><a href="http://deeeet.com/writing/2016/11/01/go-api-client/">GolangでAPI Clientを実装する | SOTA</a></li>
<li><a href="http://mattn.kaoriya.net/software/lang/go/20161101151118.htm">Big Sky :: GolangでAPI Clientを実装する、の続き</a></li>
</ul>


<p>今週のやつではなく先週のです．今週のは特に知見がなかった&hellip;<a href="https://github.com/grpc/grpc-go">grpc-go</a>とか使えたらクライアント勝手に生成されるしいいよねgrpc流行ると便利そう(感想) くらい</p>

<p><a href="http://deeeet.com/writing/2016/10/25/go-interface-testing/">Golangにおけるinterfaceをつかったテスト技法 | SOTA</a>
めっちゃいいなーと思ったんですが，テスト用 の mock を気軽に作るテクニックはあまり詳しく紹介されてなかったのでそのあたりの１つのテクニックを書きたい．</p>

<h2>前提</h2>

<p>僕もテストフレームワークや外部ツールは全く使わない．標準のtestingパッケージのみを使う．
<a href="https://github.com/stretchr/testify">testify</a> もいらないし， mock するために <a href="https://github.com/golang/mock">gomock</a> も基本はいらない．</p>

<p>とにかくGolangだけで書くのが気持ちがいい，に尽きる．</p>

<h2>テスト用 fake client をつくる</h2>

<p>全体の動くはずのgist: <a href="https://gist.github.com/haya14busa/27a12284ad74477a6fd6ed66d0d153ee">https://gist.github.com/haya14busa/27a12284ad74477a6fd6ed66d0d153ee</a></p>

<p>例えばこういう実装のテストを書くときのことを考えます．</p>

<pre><code>package main

import (
    "context"
    "fmt"
)

type GitHub interface {
    CreateRelease(ctx context.Context, opt *Option) (string, error)
    GetRelease(ctx context.Context, tag string) (string, error)
    DeleteRelease(ctx context.Context, releaseID int) error
}

type GhRelease struct {
    c GitHub
}

func (ghr *GhRelease) CreateNewRelease(ctx context.Context) (*Release, error) {
    tag, err := ghr.c.CreateRelease(ctx, nil)
    if err != nil {
        return nil, fmt.Errorf("failed to create release: %v", err)
    }

    // check created release
    if _, err := ghr.c.GetRelease(ctx, tag); err != nil {
        return nil, fmt.Errorf("failed to get created release: %v", err)
    }

    // ...
    return &amp;Release{}, nil
}

type Option struct{}
type Release struct{}
</code></pre>

<p>GitHub interface をテストでは mock したものを使いたい．そういうときには以下のように mock を作ると便利です．</p>

<pre><code>type fakeGitHub struct {
    // インターフェース埋め込み
    GitHub
    FakeCreateRelease func(ctx context.Context, opt *Option) (string, error)
    FakeGetRelease    func(ctx context.Context, tag string) (string, error)
    // 埋め込みを使うので，例えば DeleteRelease はまだテストしないので mock
    // しない... いうことができる．
}

func (c *fakeGitHub) CreateRelease(ctx context.Context, opt *Option) (string, error) {
    return c.FakeCreateRelease(ctx, opt)
}

func (c *fakeGitHub) GetRelease(ctx context.Context, tag string) (string, error) {
    return c.FakeGetRelease(ctx, tag)
}
</code></pre>

<p><code>fakeGitHub</code> という struct を作成し，インターフェースをとにかく満たすために <code>GitHub</code>
interface を埋め込みます．</p>

<p>そして mock したいメソッドは新たに <code>func (c *fakeGitHub) CreateRelease(...) (...)</code> と
定義しなおし，実装の中身は <code>fakeGitHub</code> に持たせた <code>FakeCreateRelease</code> field に丸投げします．</p>

<p>このようにしてテスト用 mock を作るとそれぞれのテストで簡単に中身の実装を変えられるので大変便利です．</p>

<p>実際にテストしてみる例</p>

<h4>main_test.go</h4>

<pre><code>package main

import (
    "context"
    "fmt"
    "testing"
)

type fakeGitHub struct {
    // インターフェース埋め込み
    GitHub
    FakeCreateRelease func(ctx context.Context, opt *Option) (string, error)
    FakeGetRelease    func(ctx context.Context, tag string) (string, error)
    // 埋め込みを使うので，例えば DeleteRelease はまだテストしないので mock
    // しない... いうことができる．
}

func (c *fakeGitHub) CreateRelease(ctx context.Context, opt *Option) (string, error) {
    return c.FakeCreateRelease(ctx, opt)
}

func (c *fakeGitHub) GetRelease(ctx context.Context, tag string) (string, error) {
    return c.FakeGetRelease(ctx, tag)
}

func TestGhRelease_CreateNewRelease(t *testing.T) {
    fakeclient := &amp;fakeGitHub{
        FakeCreateRelease: func(ctx context.Context, opt *Option) (string, error) {
            return "v1.0", nil
        },
        FakeGetRelease: func(ctx context.Context, tag string) (string, error) {
            return "", fmt.Errorf("failed to get %v release!", tag)
        },
    }

    ghr := &amp;GhRelease{c: fakeclient}

    release, err := ghr.CreateNewRelease(context.Background())
    if err != nil {
        t.Error(err)
        // =&gt; failed to get created release: failed to get v1.0 release!
    }
    _ = release
    // ...
}
</code></pre>

<p>以下のような感じで，簡単にテスト用mockの実装を書いて，テストすることができます．</p>

<pre><code>    fakeclient := &amp;fakeGitHub{
        FakeCreateRelease: func(ctx context.Context, opt *Option) (string, error) {
            return "v1.0", nil
        },
        FakeGetRelease: func(ctx context.Context, tag string) (string, error) {
            return "", fmt.Errorf("failed to get %v release!", tag)
        },
    }
</code></pre>

<p>上記の例では1種類の実装しかテストしてないのであまり恩恵がわかりづらいかも知れないですが，
例えば error が帰ってきたときに正しくエラーハンドリングできてるかとか，
返り値をいろいろ変えたものをいくつか作ってテストする&hellip;といったことが上記のパターンを
使うことによって簡単にできます．Table Testing することも可能．</p>

<p>普通にわざわざstructごと作っていると，例えばテストの関数ないでは struct の method (e.g. <code>func (c *client) Func()</code>)
を定義することができません．</p>

<p>そこで <code>FakeFunc func()</code> というfield を持たせて実装を丸投げすることによって，
簡単にいろんな実装のテスト用 mock を作成してテストができるということの紹介でした．</p>

<h2>まとめ</h2>

<p>僕は最初にこのパターンを教わってなるほどなぁ&hellip;と思ったんですが，いざ世にでてみると(?)
ぜんぜんこのパターンを紹介しているものが見つからなかったので紹介してみました．
(一応どっかの medium の英語記事にこれに似たパターンが紹介されてたのを見た気もする&hellip;)</p>

<p>ぜひ使ってみてください．</p>

<h2>あまり関係ない追記</h2>

<p>この記事の主旨とは関係ないけど，基本的にテスト用ライブラリは使わないとはいえ，
たまににヘルパー関数ほしいなーというケースがあります．</p>

<p>でかい struct をテストで比較するときに，比較自体は <code>reflect.DeepEqual</code> で出来るのだけど，
もし違っていたときにどこが違うかを表示するのが面倒くさいのでヘルパー関数提供してくれるライブラリがほしい&hellip;</p>

<p>某社でgoのテスト書いてたときもこういう大きめのstruct比較するケースでは便利diff表示用ライブラリを
使っていた気がしたんだけど，なんかOSSで見つからない気がする&hellip; prettycmp みたいな名前だった気がするが
どうだったか&hellip; そもそも記憶違いな気もする&hellip;</p>

<p>追記: twitter で教えてもらいましたが <a href="https://github.com/kylelemons/godebug">https://github.com/kylelemons/godebug</a> っぽいです．
便利. <a href="https://godoc.org/github.com/kylelemons/godebug/pretty#Compare">https://godoc.org/github.com/kylelemons/godebug/pretty#Compare</a></p>
]]></content>
  </entry>
  
</feed>
