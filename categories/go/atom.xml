<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: go | haya14busa]]></title>
  <link href="http://haya14busa.com/categories/go/atom.xml" rel="self"/>
  <link href="http://haya14busa.com/"/>
  <updated>2016-12-25T23:55:44+09:00</updated>
  <id>http://haya14busa.com/</id>
  <author>
    <name><![CDATA[haya14busa]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Go の CI で lint と カバレッジ回して非人間的部分のレビューを自動化する in 2016年]]></title>
    <link href="http://haya14busa.com/ci-for-go-in-end-of-2016/"/>
    <updated>2016-12-25T23:15:50+09:00</updated>
    <id>http://haya14busa.com/ci-for-go-in-end-of-2016</id>
    <content type="html"><![CDATA[<p>この記事は <a href="http://qiita.com/advent-calendar/2016/go3">Go (その3) Advent Calendar 2016</a> の24日目の記事です．(代打)
メリークリスマス!</p>

<p>本記事では Go 言語プロジェクトの CI で回すと便利な各種lintの紹介やカバレッジ計測の方法について紹介します．</p>

<h2>Go 言語おすすめ linter</h2>

<p>Go の lint 一覧といえば <a href="https://github.com/alecthomas/gometalinter">gometalinter</a> じゃん?
みたいな話もあると思うのですが，CIで回すには個別のいい linterを明示的に回すほうが良いかと思います．
ということで 僕が普段使ってるオススメ linter の紹介です．</p>

<h3>go vet</h3>

<ul>
<li><a href="https://golang.org/cmd/vet/">vet - The Go Programming Language</a></li>
<li>おすすめ度: ★★★★★</li>
</ul>


<blockquote><p>Vet examines Go source code and reports suspicious constructs, such as Printf
calls whose arguments do not align with the format string. Vet uses
heuristics that do not guarantee all reports are genuine problems, but it can
find errors not caught by the compilers.</p></blockquote>

<p>Go 言語標準でついているlintツールで，コンパイラが検出しないエラーを検出できます．
false positive な結果も無いようにデザインされているのでエラーがリポートされた場合は安心してCIをfailにできます．
go vet に検出されたエラーはほぼ100%直したほうがよいでしょう．</p>

<h3>golint</h3>

<ul>
<li><a href="https://github.com/golang/lint">golang/lint: This is a linter for Go source code.</a></li>
<li>おすすめ度: ★★★★☆</li>
</ul>


<blockquote><p>Golint differs from gofmt. Gofmt reformats Go source code, whereas golint prints out style mistakes.
Golint differs from govet. Govet is concerned with correctness, whereas golint is concerned with coding style.</p></blockquote>

<p>gofmtがコードのリフォーマットを，govetがコードの正確性をチェックするのに対して，golint
は Go のソースコードの <strong>&ldquo;コーディングスタイル&rdquo;</strong>
の問題を報告します．これはエラーというよりも &ldquo;suggestion&rdquo; に近く，
基本的に従っていたほうがGoの慣習に沿った確実によいコードになるのですが，
まれに，いやここの関数はコメント書かなくても絶対いいよね&hellip;とかいうケースもあり
若干消耗することもあるので星4です．</p>

<h3>errcheck</h3>

<ul>
<li><a href="https://github.com/kisielk/errcheck">kisielk/errcheck: errcheck checks that you checked errors.</a></li>
<li>おすすめ度: ★★★☆☆</li>
</ul>


<p>errcheck は関数のエラーの返り値をハンドリングチェックしているかどうかを静的に解析してくれるツールです．
エラーを捨てた状態の場合思わぬ動作(nilになってたりだとか)するので，これをチェックしてくれるのは大変嬉しいです．</p>

<p>ただし，少し実際直さなくてもいいという意味でのfalse positive が多くCIで動かすには工夫が必要で星3です．エラーをチェックしてくれるという便利度は満点．
なお，最近は標準ライブラリで必ずエラーnilとして返ってくるような関数についてはリポートしないという
false positive を減らす工夫もされているようです．</p>

<h3>staticcheck</h3>

<ul>
<li><a href="https://github.com/dominikh/go-staticcheck">dominikh/go-staticcheck: Staticcheck is go vet on steroids, applying a ton of static analysis checks you might be used to from tools like ReSharper for C#</a></li>
<li>おすすめ度: ★★★★★</li>
</ul>


<p>staticcheck は一言で言うとサードパーティーの <code>go vet</code>です．go vet でチェックされていないようなことを静的に解析してくれます．
(例えば正規表現がvalidかチェックしてくれるかなどなど&hellip;たくさん項目があるのでREADMEを見てみてください．)</p>

<p>作者の <a href="https://github.com/dominikh">dominikh さん</a> は Go
言語の開発にも関わっていて，dominikh さん製Go lint ツールは個人的には
信頼できる印象です．github/go の issue でも  go vet のissueなどに， staticcheck
は実際こういうのチェックしてるけどと言った感じで参照されてたりするのを見かけます．</p>

<p>そして次の2つのツールも dominikh さん製です．</p>

<h3>gosimple</h3>

<ul>
<li><a href="https://github.com/dominikh/go-simple">dominikh/go-simple: Gosimple is a linter for Go source code that specialises on simplifying code</a></li>
<li>おすすめ度: ★★★★★</li>
</ul>


<p>TODO: すいませんもうチョット追記しますが，一旦アドベントカレンダー25締め切りのために登録します!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go で Vim プラグインを書く]]></title>
    <link href="http://haya14busa.com/vim-go-client/"/>
    <updated>2016-12-21T18:14:54+09:00</updated>
    <id>http://haya14busa.com/vim-go-client</id>
    <content type="html"><![CDATA[<p>この記事は <a href="http://qiita.com/advent-calendar/2016/vim">Vim アドベントカレンダー 2016</a> の21日目の記事です．</p>

<p>最近は Go 言語が大好きすぎて，Vim plugin も Go で書きたい!!! という欲が出てきたので，
Vim plugin を Go で書く方法について紹介します．</p>

<h2>Go で Vim plugin を書くとは?</h2>

<p>一口に Go で Vim plugin を書くといっても</p>

<ol>
<li>Go で書いたバイナリがメインで Vim script の autoload 関数などから呼ぶ．例: <a href="https://github.com/mattn/vim-filewatcher">https://github.com/mattn/vim-filewatcher</a></li>
<li>Go 側からも Vim script を呼ぶ，つまり Vim script で Vim の情報を取得するところなど含めて，ほぼ全部 Go で書く．</li>
</ol>


<p>という 2 段階があると思います．本記事では2の方法も含めて紹介しますがまずは1から行きましょう．</p>

<h2>1. Go で書いたバイナリをつかった Vim plugin の作り方</h2>

<p>これは先程例にあげた <a href="https://github.com/mattn/vim-filewatcher">https://github.com/mattn/vim-filewatcher</a> がシンプルでわかりやすいです．</p>

<p><a href="https://github.com/mattn/vim-filewatcher/blob/22594895e16cb4de11afa37f04d88a996f48da58/filewatcher/filewatcher.go">filewatcher/filewatcher.go</a>
で書いた Go をインストール時に <code>cd filewatcher &amp;&amp; go get -d &amp;&amp; go build</code> でビルドし，
<a href="https://github.com/mattn/vim-filewatcher/blob/22594895e16cb4de11afa37f04d88a996f48da58/autoload/filewatcher.vim">autoload/filewatcher.vim</a>
でこのバイナリを <code>job</code> をつかって呼んでいます．</p>

<p><code>go get -d</code> を呼ぶことで依存するパッケージをダウンロードし，<code>go build</code> することで <code>$GOBIN</code> などを汚さずにプラグインディレクトリにバイナリを配置できます．</p>

<h4><a href="https://github.com/mattn/vim-filewatcher/blob/22594895e16cb4de11afa37f04d88a996f48da58/autoload/filewatcher.vim">autoload/filewatcher.vim</a></h4>

<pre><code>let s:cmd = expand('&lt;sfile&gt;:h:h:gs!\\!/!') . '/filewatcher/filewatcher' . (has('win32') ? '.exe' : '')
if !filereadable(s:cmd)
  finish
endif

function! filewatcher#watch(dir, cb)
  return {'dir': a:dir, 'job': job_start([s:cmd, a:dir], { 'out_cb': a:cb, 'out_mode': 'nl' })}
endfunction
</code></pre>

<p>バイナリを呼んでいるVim script もとてもシンプルで， windows かどうか見ながらバイナリのパスを取得し，
それを <code>job</code> で呼ぶだけです．簡単．プラグインの性質によっては <code>job</code> ではなく <code>system()</code> などを使ってもよいでしょう．</p>

<p>また，開発時には <code>g:plugin_name#debug</code> などを作ってそれを見て <code>go run</code> を呼ぶというふうに変えることもできます．</p>

<pre><code>function! s:separator() abort
  return fnamemodify('.', ':p')[-1 :]
endfunction

let s:is_windows = has('win16') || has('win32') || has('win64') || has('win95')

let s:base = expand('&lt;sfile&gt;:p:h:h')
let s:basecmd = s:base . s:separator() . fnamemodify(s:base, ':t')
let s:cmd = s:basecmd . (s:is_windows ? '.exe' : '')

if g:plugin_name#debug
  let s:cmd = ['go', 'run', s:basecmd . '.go']
elseif !filereadable(s:cmd)
  call system(printf('cd %s &amp;&amp; go get -d &amp;&amp; go build', s:base))
endif
</code></pre>

<p>僕が作ったプラグインから引っ張ってきた例で autoload/filewatcher.vim ほどシンプルではないですが，もうちょっとなんとか出来るかもしれないですね．
main パッケージのファイル (<code>s:basecmd . '.go'</code>) を1ファイルにすると<code>go run</code>で呼びやすいです．</p>

<h2>2. Go 側からも Vim script を呼ぶ必要があるようなプラグインの作り方</h2>

<p>mattn/filewatcher ではファイルの変更を検知してstdout にJSONを吐いて，それが job の callback に渡されるという形式で単体で簡潔してましたが，
場合によっては Go 側から Vim の状態を取得したり，Vim script を呼んだりしたい場合もあります．
そういうプラグインを作るには，job を JSON モードで起動し， <a href="http://vim-jp.org/vimdoc-ja/channel.html#channel-commands">:h channel-commands</a>
を使うことによって実現できます．</p>

<h4><a href="http://vim-jp.org/vimdoc-ja/channel.html#channel-commands">:h channel-commands</a></h4>

<pre><code>JSON チャンネルを使用すると、サーバープロセス側はVimへコマンドを送信できます。
そのコマンドはチャンネルのハンドラーを介さずに、Vimの内部で実行されます。

実行可能なコマンドは以下のとおりです:           *E903* *E904* *E905*
    ["redraw", {forced}]
    ["ex",     {Ex コマンド}]
    ["normal", {ノーマルモードコマンド}]
    ["eval",   {式}, {数値}]
    ["expr",   {式}]
    ["call",   {func name}, {argument list}, {number}]
    ["call",   {func name}, {argument list}]
</code></pre>

<p><code>{数値}</code>(<code>{number}</code>) は id で，job -> Vim に渡すさいはマイナスを指定する必要があり，
その渡した id と共に評価された値が返ってきます．</p>

<p>例えば Go 側で stdout に <code>["expr","line('$')", -2]</code> を書き込むと， Vim
が<code>line('$')</code> を評価してその結果が stdin に <code>[-2, "last line"]</code>
といった結果が返ってきます．</p>

<p>便利すぎる&hellip;</p>

<p>ということでidの取扱などこのあたりの処理を毎回丁寧にやるのは面倒くさいので，
<a href="https://github.com/haya14busa/vim-go-client">https://github.com/haya14busa/vim-go-client</a> というラッパーを作りました．
ドキュメント: <a href="https://godoc.org/github.com/haya14busa/vim-go-client#Client">https://godoc.org/github.com/haya14busa/vim-go-client#Client</a></p>

<p><a href="https://godoc.org/github.com/haya14busa/vim-go-client#Client"><code>type Client</code></a> が上記の channel-commands などのに相当するメソッドを持っており，
<a href="https://godoc.org/github.com/haya14busa/vim-go-client#Handler"><code>type Handler</code></a> がメッセージの受け渡しを担当します．</p>

<p>サンプル: <a href="https://github.com/haya14busa/vim-go-client/blob/32a96bf256fabc81dff549a70328a6bb3f24e9b5/_example/dev/job/job.go"><code>_example/dev/job/job.go</code></a></p>

<pre><code>package main

import (
    "fmt"
    "log"
    "os"
    "time"

    vim "github.com/haya14busa/vim-go-client"
)

type myHandler struct{}

func (h *myHandler) Serve(cli *vim.Client, msg *vim.Message) {
    log.Printf("receive: %#v", msg)
    if msg.MsgID &gt; 0 {

        if msg.Body == "hi" {
            cli.Send(&amp;vim.Message{
                MsgID: msg.MsgID,
                Body:  "hi how are you?",
            })
        } else {
            start := time.Now()
            log.Println(cli.Expr("eval(join(range(10), '+'))"))
            log.Printf("cli.Expr: finished in %v", time.Now().Sub(start))
        }

    }
}

func main() {
    handler := &amp;myHandler{}
    cli := vim.NewClient(vim.NewReadWriter(os.Stdin, os.Stdout), handler)
    done := make(chan error, 1)
    go func() {
        done &lt;- cli.Start()
    }()

    cli.Ex("echom 'hi'")
    log.Println(cli.Expr("1+1"))

    select {
    case err := &lt;-done:
        fmt.Printf("exit with error: %v\n", err)
        fmt.Println("bye;)")
    }
}
</code></pre>

<p><code>handler := &amp;myHandler{}</code> でハンドラを作って <code>cli := vim.NewClient(vim.NewReadWriter(os.Stdin, os.Stdout), handler)</code>
で stdin/stdout を介してVim と通信できるclientを作成しています．
あとはこいつを <code>cli.Start()</code> しておけば Vim から <code>ch_sendexpr()</code> などが呼ばれると handler に中身が渡されるし，
<code>cli.Ex("echom 'hi'")</code> などを呼ぶと Vim 側で <code>echom 'hi'</code> が実行されます．</p>

<h2>実例: vim-stacktrace</h2>

<p>実際に vim-go-client を使ってひとつプラグインを書いてみました．</p>

<p><a href="https://github.com/haya14busa/vim-stacktrace">haya14busa/vim-stacktrace</a></p>

<p><img src="https://raw.githubusercontent.com/haya14busa/i/e7ef65e590e850ea37425c6ebf4479c1422ef8c8/vim-stacktrace/stacktracefromhist.gif" alt="stacktracefromhist.gif (1287×800)" /></p>

<p>Vim のスタックトレースをquickfix に流し込むプラグインでやっていることとしては6日目の記事の <a href="http://qiita.com/tmsanrinsha/items/0787352360997c387e84">Vim scriptのエラーメッセージをパースしてquickfixに表示する - Qiita</a>
と近いです．</p>

<p>autoload 関数からjobに <code>ch_evalexpr</code>
する部分([link]<a href="https://github.com/haya14busa/vim-stacktrace/blob/933f9d10c7ef99467c27609fcdd80be37c0712e8/autoload/stacktrace.vim#L12-L30">https://github.com/haya14busa/vim-stacktrace/blob/933f9d10c7ef99467c27609fcdd80be37c0712e8/autoload/stacktrace.vim#L12-L30</a>())
を除いてほぼ全てがGoで実装されていて，現時点で Go の割合が 87.8 % です．</p>

<p><img src="https://cloud.githubusercontent.com/assets/3797062/21386073/5e56a5aa-c7b4-11e6-9cac-869cbb8ffe8d.png" alt="image" /></p>

<p>実装の中身としても，Vim のスタックトレースからは関数内における行番号しかとれず，ファイルの行番号が取得できない問題があるのですが，
それをGoで実装したVim script parser (<a href="https://github.com/haya14busa/go-vimlparser">https://github.com/haya14busa/go-vimlparser</a>) を使ってファイルをパースし，行番号を取得することができています．
また，<code>:CStacktraceFromhist</code> などは Vim script の <code>inputlist</code> をGo側から呼んでいてインテラクティブにVimと協調して動作できることも示せました．</p>

<h2>Go で書くよさ</h2>

<p>実際に Vim script でやっているひともいたように，vim-stacktrace は Go
が無いとかけなかったといった類のものではないですが，Goで書くといいことがたくさんありました．</p>

<ul>
<li>型がある安心感</li>
<li>テストが標準に備わっていて書きやすい (go test)</li>
<li>カバレッジも取れる! (go test -coverprofile)</li>
<li>Go のパッケージが使える (go-vimlparser, etc&hellip;)</li>
<li>etc&hellip;</li>
</ul>


<p>カバレッジなどは現在Vim scriptのテスティングフレームワークではサポートされていないし，なかなか実装しようとしてもムズカシそうなのですが，
Goでかけば標準でついてきます．とても便利．</p>

<p>coverall も使えます: <a href="https://coveralls.io/github/haya14busa/vim-stacktrace?branch=master"><img src="https://coveralls.io/repos/github/haya14busa/vim-stacktrace/badge.svg?branch=master" alt="Coverage Status" /></a></p>

<p>逆にPure Vim script と比較して悪いところや注意点があるとすれば</p>

<ul>
<li>vim-go-client がまだ安定してない</li>
<li>channel-commands がエラーをちゃんと返してくれない(エラーがあれば &ldquo;ERROR&rdquo; とだけ返ってくる)</li>
<li>チャンネルの通信で少しだけオーバーヘッドがある</li>
<li>現状vim/neovimに両対応できない</li>
</ul>


<p>といった感じでしょうか．もうちょっとvim-go-client精錬させたいですね&hellip;頑張ります&hellip;</p>

<h2>NeoVim のリモートプラグイン</h2>

<p>neovim 向けには実は <a href="https://github.com/neovim/go-client">neovim/go-client</a> というものが存在し，リモートプラグインをGoで書くことが出来るようです．</p>

<p><a href="http://vimconf.vim-jp.org/2016/">Vimconf 2016</a> で <a href="https://github.com/zchee">zchee</a> さんが発表していた nvim-go はこれが使われています．</p>

<p>スライド該当部分: <a href="http://go-talks.appspot.com/github.com/zchee/talks/vimconf2016.slide#33">http://go-talks.appspot.com/github.com/zchee/talks/vimconf2016.slide#33</a></p>

<p>正直なところ neovim のリモートプラグインの先行アドバンテージ(?)は大きく，vim-go-client と比較してかなり高機能になってます．
理想としては Vim 8 でも neovim でも使えるものをかけるようにしたいのですが， neovimのリモートプラグインが高機能であることや，
msgpack 依存であることからなかなか両方に対応することはムズカシイです&hellip;</p>

<p>うまく抽象化してロジックの部分だけ共通化して，vim8用/neovim用にメッセージのハンドラを管理してうんたん&hellip;みたいなことは出来るかも知れないので，
今後の研究課題という感じですね．あと僕がほとんどneovim使わないので nvim-go の仕様感とか知っている方はお話してくれると嬉しいです．
(Vimconf で zchee さんとその話ができたのは便利だった&hellip;)</p>

<h2>おわりに</h2>

<p>正直まだまだGoで書かれたVim plugin は少なく発展途上ですが，実用的なプラグインを作成することもできたので，可能性を感じます．
Go でかけばマルチプラットフォームに対応できるし，ライブラリがどうとか環境がどうとか気にすることなく動かせるので，Vim との親和性はかなり高いと思っています．</p>

<p>何よりGoはかわいい!書いていて楽しい!</p>

<p>まだまだ発展途上ですが，ぜひ皆さんもGoでVim プラグインを作ってみてください．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golangにおけるinterfaceをつかったテストで mock を書く技法]]></title>
    <link href="http://haya14busa.com/golang-how-to-write-mock-of-interface-for-testing/"/>
    <updated>2016-11-02T07:19:14+09:00</updated>
    <id>http://haya14busa.com/golang-how-to-write-mock-of-interface-for-testing</id>
    <content type="html"><![CDATA[<p>いい記事に感化されて僕も何か書きたくなった。</p>

<p><a href="http://deeeet.com/writing/2016/10/25/go-interface-testing/">Golangにおけるinterfaceをつかったテスト技法 | SOTA</a></p>

<p>リスペクト:</p>

<ul>
<li><a href="http://mattn.kaoriya.net/software/lang/go/20161025113154.htm">Big Sky :: golang で終了を確認するテストの書き方</a></li>
<li><a href="http://deeeet.com/writing/2016/11/01/go-api-client/">GolangでAPI Clientを実装する | SOTA</a></li>
<li><a href="http://mattn.kaoriya.net/software/lang/go/20161101151118.htm">Big Sky :: GolangでAPI Clientを実装する、の続き</a></li>
</ul>


<p>今週のやつではなく先週のです．今週のは特に知見がなかった&hellip;<a href="https://github.com/grpc/grpc-go">grpc-go</a>とか使えたらクライアント勝手に生成されるしいいよねgrpc流行ると便利そう(感想) くらい</p>

<p><a href="http://deeeet.com/writing/2016/10/25/go-interface-testing/">Golangにおけるinterfaceをつかったテスト技法 | SOTA</a>
めっちゃいいなーと思ったんですが，テスト用 の mock を気軽に作るテクニックはあまり詳しく紹介されてなかったのでそのあたりの１つのテクニックを書きたい．</p>

<h2>前提</h2>

<p>僕もテストフレームワークや外部ツールは全く使わない．標準のtestingパッケージのみを使う．
<a href="https://github.com/stretchr/testify">testify</a> もいらないし， mock するために <a href="https://github.com/golang/mock">gomock</a> も基本はいらない．</p>

<p>とにかくGolangだけで書くのが気持ちがいい，に尽きる．</p>

<h2>テスト用 fake client をつくる</h2>

<p>全体の動くはずのgist: <a href="https://gist.github.com/haya14busa/27a12284ad74477a6fd6ed66d0d153ee">https://gist.github.com/haya14busa/27a12284ad74477a6fd6ed66d0d153ee</a></p>

<p>例えばこういう実装のテストを書くときのことを考えます．</p>

<pre><code>package main

import (
    "context"
    "fmt"
)

type GitHub interface {
    CreateRelease(ctx context.Context, opt *Option) (string, error)
    GetRelease(ctx context.Context, tag string) (string, error)
    DeleteRelease(ctx context.Context, releaseID int) error
}

type GhRelease struct {
    c GitHub
}

func (ghr *GhRelease) CreateNewRelease(ctx context.Context) (*Release, error) {
    tag, err := ghr.c.CreateRelease(ctx, nil)
    if err != nil {
        return nil, fmt.Errorf("failed to create release: %v", err)
    }

    // check created release
    if _, err := ghr.c.GetRelease(ctx, tag); err != nil {
        return nil, fmt.Errorf("failed to get created release: %v", err)
    }

    // ...
    return &amp;Release{}, nil
}

type Option struct{}
type Release struct{}
</code></pre>

<p>GitHub interface をテストでは mock したものを使いたい．そういうときには以下のように mock を作ると便利です．</p>

<pre><code>type fakeGitHub struct {
    // インターフェース埋め込み
    GitHub
    FakeCreateRelease func(ctx context.Context, opt *Option) (string, error)
    FakeGetRelease    func(ctx context.Context, tag string) (string, error)
    // 埋め込みを使うので，例えば DeleteRelease はまだテストしないので mock
    // しない... いうことができる．
}

func (c *fakeGitHub) CreateRelease(ctx context.Context, opt *Option) (string, error) {
    return c.FakeCreateRelease(ctx, opt)
}

func (c *fakeGitHub) GetRelease(ctx context.Context, tag string) (string, error) {
    return c.FakeGetRelease(ctx, tag)
}
</code></pre>

<p><code>fakeGitHub</code> という struct を作成し，インターフェースをとにかく満たすために <code>GitHub</code>
interface を埋め込みます．</p>

<p>そして mock したいメソッドは新たに <code>func (c *fakeGitHub) CreateRelease(...) (...)</code> と
定義しなおし，実装の中身は <code>fakeGitHub</code> に持たせた <code>FakeCreateRelease</code> field に丸投げします．</p>

<p>このようにしてテスト用 mock を作るとそれぞれのテストで簡単に中身の実装を変えられるので大変便利です．</p>

<p>実際にテストしてみる例</p>

<h4>main_test.go</h4>

<pre><code>package main

import (
    "context"
    "fmt"
    "testing"
)

type fakeGitHub struct {
    // インターフェース埋め込み
    GitHub
    FakeCreateRelease func(ctx context.Context, opt *Option) (string, error)
    FakeGetRelease    func(ctx context.Context, tag string) (string, error)
    // 埋め込みを使うので，例えば DeleteRelease はまだテストしないので mock
    // しない... いうことができる．
}

func (c *fakeGitHub) CreateRelease(ctx context.Context, opt *Option) (string, error) {
    return c.FakeCreateRelease(ctx, opt)
}

func (c *fakeGitHub) GetRelease(ctx context.Context, tag string) (string, error) {
    return c.FakeGetRelease(ctx, tag)
}

func TestGhRelease_CreateNewRelease(t *testing.T) {
    fakeclient := &amp;fakeGitHub{
        FakeCreateRelease: func(ctx context.Context, opt *Option) (string, error) {
            return "v1.0", nil
        },
        FakeGetRelease: func(ctx context.Context, tag string) (string, error) {
            return "", fmt.Errorf("failed to get %v release!", tag)
        },
    }

    ghr := &amp;GhRelease{c: fakeclient}

    release, err := ghr.CreateNewRelease(context.Background())
    if err != nil {
        t.Error(err)
        // =&gt; failed to get created release: failed to get v1.0 release!
    }
    _ = release
    // ...
}
</code></pre>

<p>以下のような感じで，簡単にテスト用mockの実装を書いて，テストすることができます．</p>

<pre><code>    fakeclient := &amp;fakeGitHub{
        FakeCreateRelease: func(ctx context.Context, opt *Option) (string, error) {
            return "v1.0", nil
        },
        FakeGetRelease: func(ctx context.Context, tag string) (string, error) {
            return "", fmt.Errorf("failed to get %v release!", tag)
        },
    }
</code></pre>

<p>上記の例では1種類の実装しかテストしてないのであまり恩恵がわかりづらいかも知れないですが，
例えば error が帰ってきたときに正しくエラーハンドリングできてるかとか，
返り値をいろいろ変えたものをいくつか作ってテストする&hellip;といったことが上記のパターンを
使うことによって簡単にできます．Table Testing することも可能．</p>

<p>普通にわざわざstructごと作っていると，例えばテストの関数ないでは struct の method (e.g. <code>func (c *client) Func()</code>)
を定義することができません．</p>

<p>そこで <code>FakeFunc func()</code> というfield を持たせて実装を丸投げすることによって，
簡単にいろんな実装のテスト用 mock を作成してテストができるということの紹介でした．</p>

<h2>まとめ</h2>

<p>僕は最初にこのパターンを教わってなるほどなぁ&hellip;と思ったんですが，いざ世にでてみると(?)
ぜんぜんこのパターンを紹介しているものが見つからなかったので紹介してみました．
(一応どっかの medium の英語記事にこれに似たパターンが紹介されてたのを見た気もする&hellip;)</p>

<p>ぜひ使ってみてください．</p>

<h2>あまり関係ない追記</h2>

<p>この記事の主旨とは関係ないけど，基本的にテスト用ライブラリは使わないとはいえ，
たまににヘルパー関数ほしいなーというケースがあります．</p>

<p>でかい struct をテストで比較するときに，比較自体は <code>reflect.DeepEqual</code> で出来るのだけど，
もし違っていたときにどこが違うかを表示するのが面倒くさいのでヘルパー関数提供してくれるライブラリがほしい&hellip;</p>

<p>某社でgoのテスト書いてたときもこういう大きめのstruct比較するケースでは便利diff表示用ライブラリを
使っていた気がしたんだけど，なんかOSSで見つからない気がする&hellip; prettycmp みたいな名前だった気がするが
どうだったか&hellip; そもそも記憶違いな気もする&hellip;</p>

<p>追記: twitter で教えてもらいましたが <a href="https://github.com/kylelemons/godebug">https://github.com/kylelemons/godebug</a> っぽいです．
便利. <a href="https://godoc.org/github.com/kylelemons/godebug/pretty#Compare">https://godoc.org/github.com/kylelemons/godebug/pretty#Compare</a></p>
]]></content>
  </entry>
  
</feed>
