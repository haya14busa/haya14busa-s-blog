<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: go | haya14busa]]></title>
  <link href="http://haya14busa.com/categories/go/atom.xml" rel="self"/>
  <link href="http://haya14busa.com/"/>
  <updated>2017-02-06T09:44:18+09:00</updated>
  <id>http://haya14busa.com/</id>
  <author>
    <name><![CDATA[haya14busa]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Go に恋した Vimmer の2016年の振り返り]]></title>
    <link href="http://haya14busa.com/2016-is-go-year/"/>
    <updated>2016-12-29T17:47:59+09:00</updated>
    <id>http://haya14busa.com/2016-is-go-year</id>
    <content type="html"><![CDATA[<p>この記事では2016年 <a href="https://twitter.com/haya14busa">@haya14busa</a> がやってきた活動，特にVimとかGo 活動をざっくり振り返ります．
個人的な備忘録です．あとポエム．</p>

<h3>過去の振り返り記事</h3>

<ul>
<li><a href="http://haya14busa.com/vim_driven_learning/">1年間『Vim駆動学習』してきて最高に楽しかったのでオススメしたい - haya14busa</a></li>
<li><a href="http://haya14busa.com/haya14busa-s-happy-vimming-year-2014/">2014年の振り返り. またはプログラミング2年目をVimに捧げるとこうなるという話 - haya14busa</a></li>
<li><a href="http://haya14busa.com/look-back-2015/">はてな，Googleインターン行ってイカやりすぎたイカVimmerの2015年の振り返り - haya14busa</a></li>
</ul>


<p>今年はざっくりプログラミング &amp; Vimmer 歴 4年目でした．
そろそろプログラミングの基礎的なところわかってなくても，まだはじめてそんな経ってなくてまだ勉強できてないんです〜，また今度やっておきますっ!
みたいな言い訳が完全に通用しない年になってきた気がします (そもそも実際に言ったことは無い)．
まだまだ学んでおきたい分野はたくさんあって，特にもうちょっとレイヤーが下の要素もやっていって理解しておきたさがありますね&hellip;</p>

<h2>&ldquo;Go&rdquo; に恋した 2016年</h2>

<p>AlphaGo, Pokemon GO, Amazon Go&hellip; &ldquo;Go&rdquo; は2016年の1つのキーワードだったように思いますが，個人的には Go 言語の &ldquo;Go&rdquo; に恋した1年でした．</p>

<p><img src="../images/post/2016-12-26-gopher-stickers-lovely.png" alt="" /></p>

<p><small>credit: <a href="https://github.com/tenntenn/gopher-stickers">Gopher by tenntenn CC BY 3.0</a></small></p>

<h3>Go との出会い</h3>

<p>Go 言語との出会いは去年インターンでGoをはじめて使ったときでした．</p>

<p>その時一目惚れ&hellip; をしたわけではありません．</p>

<p>シンプルでとにかくプロジェクトで動くものは作れる感じだったので，なんとなくGoよさそうかなぁとは感じつつも，
ちょっと気になっている子(Scala) との大きな違いに戸惑ってたりしてました．
&ldquo;Functional Programming&rdquo;? なにそれおいしいの? とでも聞こえてきそうな Go の雰囲気に，
僕は一歩足を引いて評価を保留してました．
ただ，さも vim で書くために生まれてきた言語では&hellip;? というほどの <code>gofmt</code>
といった周辺のツールの充実っぷりはこの頃から大好きで，言語というよりは周囲の
エコシステムがよさ&hellip;という印象でした．</p>

<p>また，Go と出会ったころと時を同じくして，僕はスプラトゥーンと出会ってました．
お家に帰って Go やってる場合ではなく，一日中イカする毎日．
イカの存在によって Go とはどこかビジネスライクな付き合いにとどまってました．イカはっょぃ．</p>

<h3>Go との別れ</h3>

<p>それから程なくして，インターンが終了しました．
Go をいちから学ぶところからはじめたにも関わらず，
終了時にある程度のものが出来たことを Go にも感謝しつつ，
一旦 Go との付き合いもお別れになりました．</p>

<p>結局，まぁなんかよさそうな言語だ程度の(ふんわり)印象でここで一旦お別れしたわけですが，
後々，このときのいい環境で Go を書いてレビューしてもらったり，
教えてもらったことはとても役に立ちました．
ありがたい．</p>

<h3>Go との再会</h3>

<p>2016年の春，忙しかった時期も一段落し，スプラトゥーンとの距離をうまく保てるようになった僕は
ちょっとした小さいツールを Go で書くことにしました．</p>

<p>理由としては，コマンドラインツールとか Go で書くのは便利そうだったことや，
来年以降もGo書くことになりそうかなぁという打算的な思考，
また同じ頃にはじめたアルバイト先のいくつかのサブシステムは Go で書かれていることもあり，
Go 書けるとそのへんも触れておもしろそうかなという気持ちがありました．</p>

<p>数カ月の Go とのお別れ期間でいろいろ忘れていることに戸惑いつつも，書いていくうちに勘も戻ってきました．
ちょっとした自分用ツールをいくつか Go で完成させて，簡単にサーバにもっていって動かすことができてよいなーと感じたり，
Google App Engine で雑に動かしたりして遊んでました．
アルバイト先でもちょっとずつ書いたりするようになって，Go と触れ合う時間は増えました．</p>

<h3>2016年秋，気づけば Go に恋に落ちてた</h3>

<p>それからも，定期的に Go で何か作ったりしてました．例えば，</p>

<ul>
<li><a href="https://github.com/haya14busa/goplay">haya14busa/goplay: The Go Playground (https://play.golang.org/) client</a>

<ul>
<li>コマンドラインから Go Playground で Go を実行したり，コードを Playground に共有するツール</li>
<li>習作という向きも強かったけど，いまでも Playground でコードを共有する際に使ったりしていて便利．</li>
</ul>
</li>
<li><a href="https://github.com/haya14busa/gopkgs">haya14busa/gopkgs: List Go packages FAST by using the same implementation as goimports</a>

<ul>
<li>goimports と同じ内部実装でGo のパッケージをリストするツール</li>
<li>goimports と同じ実装なので <code>.goimportsignore</code> も見てくれてたりなど速い．</li>
<li>peco/fzf/unite といったフィルタリングツールと組み合わせて，import したり godoc を開いたりなどして今も便利に使ってる．</li>
</ul>
</li>
<li><a href="https://github.com/haya14busa/goverage">haya14busa/goverage: go test -coverprofile for multiple packages</a>

<ul>
<li>マルチパッケージ対応版 go test -coverprofile</li>
<li>関連記事: <a href="http://haya14busa.com/ci-for-go-in-end-of-2016/">Go の CI で lint と カバレッジ回して非人間的なレビューは自動化しよう in 2016年 - haya14busa</a></li>
</ul>
</li>
<li>関連Post: <a href="https://medium.com/@haya14busa/golang-tips-you-might-not-know-1c90e6921a3#.4h65zgqzb">Golang tips you might not know – Medium</a></li>
</ul>


<p>この頃には Go がかなり手に馴染むようになってきました．上記に上げたツールも Go
の開発を助けるツールだということからも，Go をより書くようになってきてることがうかがえます．</p>

<p>特にきっかけはありませんでした．でもこの頃にはもう Go に恋してたんだと思います．
その結果，特に意味もなく Vim script のパーサを Go 言語で動かしたいなぁ&hellip;
既存の Python 実装とかあるけど，Go でいじりたいなぁ&hellip; と思って Go 実装を作ったりしてました．</p>

<h4>go-vimlparser - Vim Script Parser written in Go</h4>

<ul>
<li>GitHub: <a href="https://github.com/haya14busa/go-vimlparser">haya14busa/go-vimlparser: Vim Script Parser written in Go</a></li>
<li>Post: <a href="https://medium.com/@haya14busa/vim-script-parser-written-in-go-4d0296782a14#.rtaybepih">Vim Script Parser written in Go – Medium</a></li>
<li>VimConf でも発表しました: <a href="https://medium.com/@haya14busa/report-of-vimconf2016-an-international-conference-for-vim-f99925893322#.d8n121p9e">Report of #vimconf2016 — an international conference for Vim – Medium</a></li>
</ul>


<p>Just for fun ではじめましたが，結果として最速 Vim script parser 実装となって，Vimmer にも嬉しい便利なものになったと思います．
Go のパフォーマンスチューニングのやり方も改めて経験できて身についたし，
AST の表現や AST walker の実装をするために <a href="https://golang.org/pkg/go/ast/">go/ast</a>
のコードを読んでインターフェースをパク&hellip;参考にしたりとおもしろかった．
Go の標準ライブラリのデザインはとても参考になるし，それを Go 言語でザクザク読めるのは本当にいいなぁと思います．</p>

<h3>Go と Vim との共同作業</h3>

<p>この頃，Vim はJSONやchannel, job 機能が実装され，外部インターフェースとの通信が容易になり，もうすぐ Vim 8.0 出すよ〜という時期でした．
Go に恋した Vimmer としては，もちろんここで Go 言語を使って Vim との共同作業をさせたいというのは必然です!
(これでは Go と Vim がカップルになってるのではということは気にしない．でも実際2人の相性はとてもよい)</p>

<p>このあたりの話は Vim Advent Calendar で書きました．</p>

<ul>
<li><a href="http://haya14busa.com/vim-go-client/">Go で Vim プラグインを書く - haya14busa</a></li>
<li><a href="https://github.com/haya14busa/vim-go-client">haya14busa/vim-go-client: [WIP] Vim 8.0 client written in go</a></li>
<li><a href="https://github.com/haya14busa/vim-stacktrace">haya14busa/vim-stacktrace: Stacktrace of Vim script</a></li>
</ul>


<p>vim-go-client の通信のハンドリングのデザインは Go の <a href="https://golang.org/pkg/net/http/">net/http</a> のコードを読んで参考にしたりしました．
が，もうちょっといい感じにできそうな気がする&hellip;
実際に Go で vim-stacktrace という便利プラグインを作れることを確認できて，go-vimlparser も有効活用できたりなど，
Vim活にも Go が絡むようになってきてますます Go が好きになっていきました．</p>

<h3>Go と Vim との間に生まれた子供 - reviewdog</h3>

<p>(Go と Vim が結婚して子供を産みました．僕のGoへの恋は片想い)</p>

<p><img src="https://raw.githubusercontent.com/haya14busa/i/d598ed7dc49fefb0018e422e4c43e5ab8f207a6b/reviewdog/reviewdog.logo.png" alt="reviewdog logo" /></p>

<ul>
<li><a href="https://github.com/haya14busa/reviewdog">haya14busa/reviewdog: A code review dog who keeps your codebase healthy</a></li>
<li><a href="https://github.com/haya14busa/errorformat">haya14busa/errorformat: Vim&rsquo;s quickfix errorformat implementation in Go</a></li>
<li><a href="http://haya14busa.com/reviewdog/">reviewdog を飼ってコードレビューや開発を改善しませんか - haya14busa</a></li>
<li><a href="https://medium.com/@haya14busa/reviewdog-a-code-review-dog-who-keeps-your-codebase-healthy-d957c471938b#.r3hb734et">reviewdog — A code review dog who keeps your codebase healthy</a></li>
</ul>


<p>reviewdog は僕の 2016年に作ったプロダクトの一番のヒット作と言えます．reviewdog の GitHub のスターは執筆時現在 268 です．
reviewdog が好きなのは，実際に超便利プロダクトだということはもちろん，Vim の &lsquo;errorformat&rsquo; という便利な機能を
Go言語で port して Vim の外でも使えるようにしたという，Vim と Go の&#8221;よさ&#8221; が存分に発揮されたプロダクトだというところがとても気に入っています．</p>

<p>reviewdog のようなものを作るには，いろんな linter などのコマンドの結果を扱わなくてはいけません．
他のツールでは， <a href="https://github.com/alecthomas/gometalinter">gometalinter</a> のように linter ごとに正規表現をアドホックに作ったり，
それぞれのコマンドの runner を作ったり， checkstyle xml やJSONのある機械的な形式を吐くlinterにのみ対応するといった割り切りをしています．</p>

<p>Vim はそういういろんなコマンドやいろんなアウトプット形式に対応するというのは得意で，
&lsquo;errorformat&rsquo; という scanf-like な機能がこれにあたり，この形式を使うことに決めました．</p>

<p>ただしこの&#8217;errorformat&#8217;は Vim でしか使えません．そこを同じくマルチプラットフォームで簡単に動く
Go 言語で同等の機能をポート(<a href="https://github.com/haya14busa/errorformat">haya14busa/errorformat</a>)し，
Vim のよさを Go がサポートしてより広く使ってもらえるようにできました．</p>

<p>reviewdog は現在もちょくちょく改善していて，特にローカルでもより動かしやすいようにしようと思ってます．
年内にある程度開発してバージョン1.0にしようかと思っていましたが，もう少しかかりそうです．</p>

<h4>reviewdog の状況</h4>

<ul>
<li><blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">reviewdogでエゴサしたらつい昨日リリースしたというのにすでに <a href="https://twitter.com/hashtag/lispmeetup?src=hash">#lispmeetup</a> というミートアップで lisp のlint ツールの発表で reviewdog 使ってくれているっぽいことを発見した&hellip;. べんりすぎる <a href="https://t.co/zYQeOVIGTX"><a href="https://t.co/zYQeOVIGTX">https://t.co/zYQeOVIGTX</a></a></p>&mdash; はやぶさ (@haya14busa) <a href="https://twitter.com/haya14busa/status/790888183844089857">October 25, 2016</a></blockquote>

<ul>
<li>スライド: <a href="http://www.slideshare.net/fukamachi/sblint">SBLint</a></li>
<li>リリースした直後に reviewdog に対応するための lint ツール作った発表とかを観測してビビった．</li>
</ul>
</li>
<li><a href="https://speakerdeck.com/fortkle/yasashii-sonogo">やさしいコーディング規約の導入〜その後〜 / yasashii-sonogo // Speaker Deck</a>

<ul>
<li>実際に使ってもらえてるっぽくてよさ</li>
</ul>
</li>
<li><a href="https://github.com/vim-jp/vital.vim/pull/458">CI: reviewdog 導入 by haya14busa · Pull Request #458 · vim-jp/vital.vim</a>

<ul>
<li>vital.vim という Vim script ライブラリのリポジトリに reviewdog 導入してもらった．</li>
</ul>
</li>
<li>reviewdog は僕がバリバリドックフーディングしているのはもちろんのこと，ちょっと使ってもらってる例はちらほら見かける．</li>
</ul>


<p>OSS で導入するのは CI サービスがうまく Secure Token を扱ってくれないせいで，
若干最初の導入が手間なのが使ってもらうには少し壁になってるのが悲しい．Travis〜CircleCI〜頼む〜改善してくれ〜．
一度導入してしまえばあとは楽だし，もしくはローカルでだけ使っても便利なのでもうちょっと使用事案増えて欲しい．</p>

<h3>Go 活動その他</h3>

<ul>
<li><a href="http://haya14busa.com/golang-how-to-write-mock-of-interface-for-testing/">Golangにおけるinterfaceをつかったテストで mock を書く技法 - haya14busa</a>

<ul>
<li>いい記事に感化されて僕も何か書きたくなった。事案</li>
</ul>
</li>
<li><a href="http://haya14busa.com/ci-for-go-in-end-of-2016/">Go の CI で lint と カバレッジ回して非人間的なレビューは自動化しよう in 2016年 - haya14busa</a>

<ul>
<li>Go の CI 周りの紹介</li>
</ul>
</li>
<li><a href="https://medium.com/@haya14busa/sum-union-variant-type-in-go-and-static-check-tool-of-switch-case-handling-3bfc61618b1e#.cp9eqobvo">Sum/Union/Variant Type in Go and Static Check Tool of switch-case handling – Medium</a>

<ul>
<li><a href="http://developer.hatenastaff.com/entry/engineer-advent-calendar-2016">はてなエンジニアアドベントカレンダー2016</a> の 6日目の記事</li>
<li>はてなの Mackerel チームでアルバイトしていて，仕事してて直和型っぽいことを表現したいときの知見がちょうどあったのでアドベントカレンダーに書かせていただきました．</li>
<li>linter はアドベントカレンダー書くなら知見共有だけよりはツールも欲しいなと書きました．<code>go/types</code> パッケージ便利．</li>
</ul>
</li>
<li>OSS Contributions

<ul>
<li><a href="https://github.com/mattn/goveralls">mattn/goveralls</a> で複数パッケージサポート足した</li>
<li>go-github で GitHub の Review API サポートのレビューをなぜかメンテナでもないけどやってる <a href="https://github.com/google/go-github/issues/495">https://github.com/google/go-github/issues/495</a>

<ul>
<li>実質 GitHub Review API の reviewer みたいにもなってて Support に要望送りまくってる</li>
</ul>
</li>
<li>あんまりやってなかった&hellip;</li>
</ul>
</li>
</ul>


<h3>Go が好き</h3>

<p>書いてるうちに手に馴染んできて，いつの間にか好きになってましたが，結局僕はなぜ Go に恋に落ちたのでしょうか．
1つは間違いなく Go の Simplicity に惹かれたんだと思います．</p>

<h4>Simplicity is Complicated</h4>

<ul>
<li>slide: <a href="https://talks.golang.org/2015/simplicity-is-complicated.slide#1">Simplicity is Complicated</a></li>
<li>youtube: <a href="https://www.youtube.com/watch?v=rFejpH_tAHM">dotGo 2015 - Rob Pike - Simplicity is Complicated - YouTube</a></li>
</ul>


<p>Rob Pike の &ldquo;Simplicity is Complicated&rdquo; という発表がオススメです．
僕はこの発表をみて，胸がきゅーーんっとなりました．Go かわいいよ Go．</p>

<p>Go はなぜ成功したんでしょうか? コンパイル速度，実行速度，デプロイの容易さ，充実したツール，質の高いライブラリ，interfaceやconcurrencyをサポートする言語機能&hellip;
そのどれもが大事で，僕も実際どれも好きですが，Rob Pike は &ldquo;Simplicity&rdquo; が答えだといいます．
そしてこの &ldquo;Simplicity&rdquo; は &ldquo;Complicated&rdquo; だとも．</p>

<p>シンプルという言葉はともすれば薄っぺらくなります．特にVimmerという職業(?)柄，
Vim plugin とかをいくつかみると，&#8221;simple&#8221; だとか，他にも &ldquo;easy&rdquo;, &ldquo;minimalictic&rdquo;
と言った単語が並んでたりします．これは自戒を込めてですが，場合によってはちょっと薄っぺらいなぁと感じるようなものもあったりします．</p>

<blockquote><p>Simplicity is the art of hiding complexity.</p></blockquote>

<p>Go が simple だとか，less is more だとか，引き算の言語だ&hellip;といった表現をされるとき，
僕は全く薄っぺらいだとかは思いません．
これは&#8221;Simplicity&#8221; というのは実は&#8221;Complicated&#8221; であり，
&ldquo;Simplicity&rdquo; の背後には&#8221;complexity&#8221;を洗練された，緻密なデザインや設計，実装が隠れているからなんだと思います．</p>

<p>GCやgoroutine,interfaceといった実際の例がスライドで説明されているので是非見てみてください．</p>

<p>僕らが享受しているGo の &ldquo;Simplicity&rdquo; は簡単に実現されたものではありません．
僕らが Go に対して，「あぁ，こういうのでいいんだよ．こういうので．」と感じるとき，
その背後には Go がたくさんの機能を削ぎ落として，直交する必要十分な機能のデザインと
複雑な実装が存在しています．</p>

<blockquote><p>Simplicity is hard—to design. <br>
Simplicity is complicated—to build. <br>
But if you get it right&hellip; <br>
Simplicity is easy—to use. <br>
The success of Go proves it. <br>
&ndash; <a href="https://talks.golang.org/2015/simplicity-is-complicated.slide#30">https://talks.golang.org/2015/simplicity-is-complicated.slide#30</a></p></blockquote>

<p>&ldquo;Simplicity&rdquo; をデザインするのは難しく，&#8221;Simplicity&#8221;の実現はとても複雑です．
でもこれらをうまくやると，&#8221;Simplicity&#8221; は使うのが簡単になります．</p>

<p>これが Go は， &ldquo;simple&rdquo; であり，&#8221;less is more&#8221; であり，&#8221;引き算の言語&#8221; であり，
「あぁ，こういうのでいいんだよ．こういうので．」ということなのでしょう．</p>

<h4>Go is more Pythonic than Python</h4>

<p><a href="https://talks.golang.org/2012/zen.slide#1">Go and the Zen of Python</a></p>

<pre><code>&gt;&gt;&gt; import this
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
</code></pre>

<p>僕が最初に学んだ言語は Python で，The Zen of Python の思想はとても好きでした．</p>

<ul>
<li>Explicit is better than implicit.</li>
<li>Simple is better than complex.</li>
<li>Readability counts.</li>
<li>There should be one&ndash; and preferably only one &ndash;obvious way to do it.</li>
</ul>


<p>Go は The Zen of Python に，ともすれば Python 以上にマッチしています．
Go が Pythonic なところも間違いなく僕が Go を好きになった一因です．
なんなら，Go が Python より Pythonic なので，もう Python で書くようなところは，
Go で書きたい．</p>

<p>Go の前に学んだ言語は Scala でした．
Scala が魅せてくれるプログラミング言語の可能性にはスゴイなぁ，おもしろいなぁ，
と思いつつも，Scala が気になる子止まりだったのは，The Zen of Python の思想の真逆を
行くような，ないし真逆のコードが生まれやすい言語だからだと思います．
Scala は今も書いているし，堅牢かつ規模の大きいコードも Scala だと比較的安心して書いていけたり，
僕に &ldquo;Functional Programming&rdquo; などを教えてくれた Scala は好きですが，恋に落ちるほどではなかった．
僕を含め，もう少し人類が進化するとまた変わってくる気もする．</p>

<h3>Go とのこれから</h3>

<p>2017年もGoと仲良くやってきたいです．個人的には特に Vim との連携とか含め．
Go 本体になんかコントリビュッションしたいと思いつつできなかったので，機会があればやっていきたい．</p>

<p>あとは，Go のよさを再確認するため(?)に別のパラダイムの言語(rust とか)にちょい浮気しつつやっていきたいですね．</p>

<h2>Vim との 2016年 - 本妻は Vim</h2>

<p>2016年のVim活もザックリ振り返ります．</p>

<h3>EasyMotion 3.0</h3>

<p><a href="http://haya14busa.com/vim-easymotion-ver-3-dot-0-overwin-motions/">Vimのカーソル移動はもっともっと爆速になる! Vim-EasyMotion v3.0 をリリースしました - haya14busa</a></p>

<p>結構前にやった気もしますが，今年でした．
バージョン3.0の機能追加でウィンドウをまたいだEasyMotionによるカーソル移動が実現しました．
完全にライフチェンジング機能だし，待望の機能の実現で自分の Vim script 力の高まりも確認できてよかった．</p>

<h3>vital のロード高速化</h3>

<ul>
<li><a href="http://haya14busa.com/revital-vim-makes-vital-vim-a-lot-faster/">revital.vim で vital.vim を爆速にしてお前らの Vim plugin を速くする - haya14busa</a></li>
<li><a href="https://github.com/vim-jp/vital.vim/pull/415">vital モジュールのロードを爆速にする &amp; ロード方法を考える by haya14busa · Pull Request #415 · vim-jp/vital.vim</a></li>
</ul>


<p>まず，revital.vim という別プラグインで vital.vim のロードを高速化できることを示した後，結局 vital.vim 本体に入れてもらいました．
ついでにリファクタリングしたりインターフェースの改善も行いました(後方互換性は維持している)．
特定の環境でvital.vimが遅いという問題を完全に解決し，現在では autoload 関数を呼ぶのと変わらなくなってます．</p>

<h3>はじめてのパッチ - Vim の Contributer に!</h3>

<ul>
<li><a href="https://github.com/vim-jp/issues/issues/893">statuslineの%{}などでevalした際に，try-catch でVimのエラーをキャッチしていても statusline が disable されてしまう · Issue #893 · vim-jp/issues</a></li>
<li><a href="https://github.com/vim/vim/commit/a742e084b677f76c67e9e52c4f9fb9ab24002e20">patch 7.4.1711 · vim/vim@a742e08</a></li>
</ul>


<p>vital のロード高速化の際に Vim のバグを踏んで，小さいですがはじめてパッチを書いて取り込まれました!
このバグは本体のバグだったということもあって異常に原因究明が難しく，原因を見つけたのは <a href="https://github.com/lambdalisue">lambdalisue</a> さんでした．</p>

<p>今年は他にも EasyMotion で踏んだバグの修正パッチや，Vim8.0 リリース前の channelやjob 機能を叩いたパッチを書いたり，
Vim 8.0 に lambda いれようぜ! ともう一回 vim-jp でちょっと騒いで，あとは vim-jp の <a href="https://github.com/mattn">mattn</a> さんや
<a href="https://github.com/k-takata">k-takata</a> さんに丸投げするなどをしてました．</p>

<p>そのあたりの話で１つ記事を書いてます -> <a href="https://medium.com/@haya14busa/vim-8-0-released-and-now-im-a-contributor-of-vim-36d93bbfc7b6#.nxkskyex2">Vim 8.0 released and Now, I’m a contributor of Vim !!! – Medium</a></p>

<p>今年になって小さいとは言え Vimのパッチ書いたりできたのはとても嬉しかったです．
Vim のソースコードも読むことは出来るし，デバッグの仕方もわかってきたし，
場合によってはちょっと修正するくらいのことも出来るということがわかったのは収穫でした．
ただ，もっと C 力は高めたほうがよさそう．</p>

<h3>Vim 8.0 &amp; Go関連</h3>

<ul>
<li>go-vimlparser</li>
<li>vim-go-client</li>
<li>vim-stacktrace</li>
<li>パッチいくつか．</li>
</ul>


<p>詳細は Go のところで紹介したので省略．</p>

<h3>VimConf</h3>

<ul>
<li><a href="https://medium.com/@haya14busa/report-of-vimconf2016-an-international-conference-for-vim-f99925893322#.d8n121p9e">Report of #vimconf2016 — an international conference for Vim – Medium</a></li>
<li><a href="https://github.com/haya14busa/vim-metarepeat">haya14busa/vim-metarepeat</a></li>
<li><a href="https://github.com/haya14busa/vim-textobj-function-syntax">haya14busa/vim-textobj-function-syntax: heuristic syntax-based text-object for function</a></li>
</ul>


<p>発表は go-vimlparser についての話ですでに書きましたが，
<a href="https://github.com/t9md">t9md</a> さんの <a href="https://github.com/t9md/atom-vim-mode-plus">t9md/atom-vim-mode-plus</a> の発表が面白くて，
Atom の vim-mode-plus のアイデアを Vim にバックポートする業などをしていました．</p>

<p><a href="https://github.com/haya14busa/vim-metarepeat">haya14busa/vim-metarepeat</a> は vim-mode-plus の occurence で出来るようになる便利な機能を別の角度から実装したもので，
ドットリピートをオペレータとして，テキストオブジェクト内の対象に対して一括でドットリピートを実行するものです．
記事には書いてないけどissueにちょっと考えとかを書いています -> <a href="https://github.com/vim-jp/issues/issues/977#issuecomment-259703728">https://github.com/vim-jp/issues/issues/977#issuecomment-259703728</a>
vim-metarepeat はかなり便利で常用していて，記事書くかぁと思いながら今年が終了しました．</p>

<p><a href="https://github.com/haya14busa/vim-textobj-function-syntax">haya14busa/vim-textobj-function-syntax</a> は関数text-objectをVimのsyntaxを使って言語ごとに用意せずに使えるようにしたものです．
syntax によって使える/使えない言語がありますが，ちょっと便利．
これも記事にはしてないけどissueにちょっとコメントしてます．-> <a href="https://github.com/vim-jp/issues/issues/987#issuecomment-262870187">https://github.com/vim-jp/issues/issues/987#issuecomment-262870187</a></p>

<h3>Google Translate の衝撃と Vim</h3>

<p><a href="https://japan.googleblog.com/2016/11/google.html">Google Japan Blog: Google 翻訳が進化しました。</a></p>

<p>今年はGoogle Translate が日英間の翻訳に Neural Machine Translation を導入して，
機械翻訳がとても流暢になりました．Google Translate さんすごい．
この改善をみて，Vimから使いやすくするためにいくつかプラグインを作りました．</p>

<ul>
<li><a href="https://github.com/haya14busa/vim-open-googletranslate">haya14busa/vim-open-googletranslate: Open Google Translate (https://translate.google.com/) from Vim.</a>

<ul>
<li>Vim から Google Translate を開く operator やコマンドを追加するプラグイン．常用してます．</li>
<li><a href="https://twitter.com/Linda_pp">りんだん</a> さんに <a href="https://github.com/rhysd/electron-open-url">rhysd/electron-open-url</a> という Electron で url を開くものを作ってもらって，これをつかって Google Translate を開く設定をすることによって，連続で翻訳しやすくなってとても便利になりました．</li>
</ul>
</li>
<li><a href="https://github.com/haya14busa/gtrans">haya14busa/gtrans: Command-line translator using Google Translate</a></li>
<li><a href="https://github.com/haya14busa/vim-gtrans">haya14busa/vim-gtrans: Google Translate in Vim</a>

<ul>
<li>Google Translate の API を使ったもの．こちらは Vim のバッファで完結できる．</li>
<li>API はめちゃめちゃ安いとはいえ，お金がかかるし，vim-open-googletranslate with electron-open-url の組み合わせが十分便利なのでそちらを最近は使ってる．</li>
</ul>
</li>
</ul>


<h2>英語でブログ記事を書く</h2>

<p>Google Translate の流れでいうと今年後半からは実験的にブログ記事も英語で書くようにしました．
Google Translate 改善前からやっていて，改善後も勿論(?)Google Translateはあくまで補助としての使用ですが．</p>

<h3>書いた英語 Posts</h3>

<ul>
<li><a href="https://medium.com/@haya14busa">haya14busa – Medium</a></li>
<li><a href="https://medium.com/@haya14busa/vim-8-0-released-and-now-im-a-contributor-of-vim-36d93bbfc7b6#.5f2fkfj0o">Vim 8.0 released and Now, I’m a contributor of Vim !!! – Medium</a></li>
<li><a href="https://medium.com/@haya14busa/vim-script-parser-written-in-go-4d0296782a14#.gj03djo2w">Vim Script Parser written in Go – Medium</a></li>
<li><a href="https://medium.com/@haya14busa/reviewdog-a-code-review-dog-who-keeps-your-codebase-healthy-d957c471938b#.80j73sekq">reviewdog — A code review dog who keeps your codebase healthy – Medium</a></li>
<li><a href="https://medium.com/@haya14busa/report-of-vimconf2016-an-international-conference-for-vim-f99925893322#.pz8doupyk">Report of #vimconf2016 — an international conference for Vim – Medium</a></li>
<li><a href="https://medium.com/@haya14busa/golang-tips-you-might-not-know-1c90e6921a3#.zhpcp2dot">Golang tips you might not know – Medium</a></li>
<li><a href="https://medium.com/@haya14busa/sum-union-variant-type-in-go-and-static-check-tool-of-switch-case-handling-3bfc61618b1e#.l22136r8d">Sum/Union/Variant Type in Go and Static Check Tool of switch-case handling – Medium</a></li>
</ul>


<p>英語で書く記事かどうか決めるというよりは，基本的に英語で書いて，どうしても日本語で書いたほうがよさそうだったら日本語で書くことにしています．
直近の2つのアドベントカレンダーは普通に日本語で書いてしまって守れてないけど&hellip;正直時間が取れなかったので日本語に逃げました&hellip;
まぁ日本語で発信するのもそれはそれで大事だと思うのでいいかなぁーとは思ってます．</p>

<p>英語で書く理由としては，今後使うし勉強のためやらなきゃ&hellip;という理由と，
発信を日本に閉じる必要性はないかなーと最近は考えてるからでした．
僕はVimとかGoについて書くことが最近は多いですが，それらの記事のターゲットは大抵 Vimmer か Gopher で，
別に想定読者を日本人に絞る必要性はないんですよね．</p>

<p>日本語で書いた後，英訳しようとはなかなか行動できないので，英語・日本語両方ポスト作ると言うよりは，
実質デファクトになってる英語で書けば英語読める日本人は読めるので，基本的には
英語で1つ記事を書くということにしました．</p>

<p>&hellip;とはいえ時間やクオリティーの兼ね合い，日本のコミュニティーの活性化，
フィードバックのもらいやすさ，そして何より現状の英語力が足りてない問題など，
色々と問題はありますが．そもそもたくさんの人に読んでもらうというのが目的ではないという観点もありそうだけど．</p>

<p>英語で書くと特に日本では伸びづらいですが，
日本で伸びなくても今までリーチしなかった層にリーチするし，
今年書いた記事はだいたいある程度は日本人もそれ以外も読んでもらえたっぽいので，
今の所やってみてよかったです．
reddit とかにあげるとそこそこ読みにきてくれて便利．(redditのCEOがコメント編集したという事件があって，若干使いたさが減りましたが&hellip;)．
来年も続けていこうかなぁと思います．</p>

<p>英語に関してはWritingもそうだけど，どちらかといえば勉強する必要があったのはSpeaking/Listeningだった気が&hellip;
という説もあり，今後がとても心配すぎる&hellip;</p>

<h2>2016年活動情報</h2>

<h3>GitHub Contributions</h3>

<ul>
<li><a href="https://github.com/haya14busa?utf8=%E2%9C%93&amp;tab=repositories&amp;q=created%3A%222016-01-01%20..%202017-01-01%22%20fork%3Afalse&amp;type=&amp;language=">作った Repositories</a></li>
<li><a href="https://github.com/search?utf8=%E2%9C%93&amp;q=is%3Apr+author%3Ahaya14busa+created%3A%222016-01-01+..+2017-01-01%22+&amp;type=Issues&amp;ref=searchresults">開いた issues</a></li>
<li><a href="https://github.com/pulls?utf8=%E2%9C%93&amp;q=is%3Apr+author%3Ahaya14busa+created%3A%222016-01-01+..+2017-01-01%22+">開いた Pull Requests</a></li>
</ul>


<p>GitHub Contributions (including private contributions)</p>

<p><img src="../images/post/2016-github-all-contributions.png" alt="GitHub Contributions (including private contributions)" /></p>

<p>GitHub Contributions (public)</p>

<p><img src="../images/post/2016-github-public-contributions.png" alt="GitHub Contributions (public)" /></p>

<h3>Posts</h3>

<ul>
<li>Jan 19 <a href="http://haya14busa.com/vim-easymotion-ver-3-dot-0-overwin-motions/">Vimのカーソル移動はもっともっと爆速になる! Vim-EasyMotion v3.0 をリリースしました - haya14busa</a></li>
<li>Mar 23 <a href="http://haya14busa.com/revital-vim-makes-vital-vim-a-lot-faster/">revital.vim で vital.vim を爆速にしてお前らの Vim plugin を速くする - haya14busa</a></li>
<li>May 30 <a href="http://haya14busa.com/amazon-kindle-sale-til-2016-06-02/">6/2までKindle本50%オフセール!IT系の本で僕が欲しい本をまとめた!!! - haya14busa</a></li>
<li>Jul 02 <a href="http://haya14busa.com/hatena-pepabo-kyoto/">はてな・ペパボ技術大会〜インフラ技術基盤〜@京都 行ってきたメモ - haya14busa</a></li>
<li>Oct 24 <a href="http://haya14busa.com/reviewdog/">reviewdog を飼ってコードレビューや開発を改善しませんか - haya14busa</a></li>
<li>Nov 02 <a href="http://haya14busa.com/golang-how-to-write-mock-of-interface-for-testing/">Golangにおけるinterfaceをつかったテストで mock を書く技法 - haya14busa</a></li>
<li>Dec 21 <a href="http://haya14busa.com/vim-go-client/">Go で Vim プラグインを書く - haya14busa</a></li>
<li>Dec 24 <a href="http://haya14busa.com/ci-for-go-in-end-of-2016/">Go の CI で lint と カバレッジ回して非人間的なレビューは自動化しよう in 2016年 - haya14busa</a></li>
</ul>


<h3>Posts (English)</h3>

<ul>
<li>Sep 13 <a href="https://medium.com/@haya14busa/vim-8-0-released-and-now-im-a-contributor-of-vim-36d93bbfc7b6#.zeqiwqjtq">Vim 8.0 released and Now, I’m a contributor of Vim !!! – Medium</a></li>
<li>Sep 20 <a href="https://medium.com/@haya14busa/vim-script-parser-written-in-go-4d0296782a14#.5ehmbn3dn">Vim Script Parser written in Go – Medium</a></li>
<li>Oct 24 <a href="https://medium.com/@haya14busa/reviewdog-a-code-review-dog-who-keeps-your-codebase-healthy-d957c471938b#.lk0e5kix0">reviewdog — A code review dog who keeps your codebase healthy – Medium</a></li>
<li>Nov 7 <a href="https://medium.com/@haya14busa/report-of-vimconf2016-an-international-conference-for-vim-f99925893322#.fe69sy14m">Report of #vimconf2016 — an international conference for Vim – Medium</a></li>
<li>Dec 1 <a href="https://medium.com/@haya14busa/golang-tips-you-might-not-know-1c90e6921a3#.77th9mu4e">Golang tips you might not know – Medium</a></li>
<li>Dec 6 <a href="https://medium.com/@haya14busa/sum-union-variant-type-in-go-and-static-check-tool-of-switch-case-handling-3bfc61618b1e#.cp9eqobvo">Sum/Union/Variant Type in Go and Static Check Tool of switch-case handling – Medium</a></li>
</ul>


<h2>歩くのが下手って気付いた2016年</h2>

<p>今年は1つ大きく躓いた出来事がありました．躓いただけなら立て直せばよかったはずだったけど，
そのまま歩き続ける意味を見失い，歩みを進めようとする心はもう折れていて，しばらくその場でうずくまってしまいました．
躓いたことにも，歩き直せなかったことにも，道を変えて歩くことさえもできずに，ただただうずくまってました．
今まで通りとはいかないにしても，もうちょっとうまく歩けたはずでした．
あぁ，僕は歩くのがなんて下手なんだ&hellip;</p>

<p>今の所，詳細はオープンインターネットには書かなくてもいいかな&hellip;と思ってます．
書く気がないのにここでふんわり書いたのは完全に自己満足です．忘年です．忘れないけど．</p>

<p>あとは完全にここでやるべきことではないけど，一種の懺悔みたいなものです．
僕が単に1人でうずくまったまま世界から消えても，別に世界はどうってことないけど，
無駄に不要なところにまで迷惑をおかけしてしまったり，いくつか見えた差し伸べられた手も
完全にシャットアウトしてしまったことは，単純に反省しています．ごめんなさい．</p>

<p>最近は人間的な生活をおくるリハビリをしていて，心に平穏は戻りつつある気はします．</p>

<h2>最後に</h2>

<p>2016年の振り返り記事だって言ってるのに無駄なポエムがところどころにあるせいで無駄に長くなった気がします．
あとオープンにやってきたこと何でもかんでも放り込み過ぎて長くなったので，もうちょっとハイライトだけ振り返ればよかった気もする．
まぁ，まだまだとはいえ，2016年結構いろいろやったのでは? と振り返って思いました．
来年の目標，なにか定量的なものを設定して振り返るのが本当は良い気がしますが，
来年はとりあえず強く生きることを目標にします．</p>

<p>来年がとても素晴らしい1年でありますように．</p>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go の CI で lint と カバレッジ回して非人間的なレビューは自動化しよう in 2016年]]></title>
    <link href="http://haya14busa.com/ci-for-go-in-end-of-2016/"/>
    <updated>2016-12-25T23:15:50+09:00</updated>
    <id>http://haya14busa.com/ci-for-go-in-end-of-2016</id>
    <content type="html"><![CDATA[<p>この記事は <a href="http://qiita.com/advent-calendar/2016/go3">Go (その3) Advent Calendar 2016</a> の24日目の記事です(代打)．
メリークリスマス!</p>

<p>本記事では Go 言語プロジェクトの CI で回すと便利な各種lintの紹介やカバレッジ計測の方法などなどについて紹介します．</p>

<h2>Go 言語おすすめ linter</h2>

<p>Go の lint 一覧といえば <a href="https://github.com/alecthomas/gometalinter">gometalinter</a> じゃん?
みたいな話もあると思うのですが，CIで回すには個別に linter を明示的に回すほうが良いかと思います．
ということで 僕が普段使ってるオススメ linter の紹介です．</p>

<h3>go vet</h3>

<ul>
<li><a href="https://golang.org/cmd/vet/">vet - The Go Programming Language</a></li>
<li>おすすめ度: ★★★★★</li>
</ul>


<blockquote><p>Vet examines Go source code and reports suspicious constructs, such as Printf
calls whose arguments do not align with the format string. Vet uses
heuristics that do not guarantee all reports are genuine problems, but it can
find errors not caught by the compilers.</p></blockquote>

<p>Go 言語標準でついているlintツールで，コンパイラが検出しないエラーを検出できます．
false positive な結果も無いようにデザインされているのでエラーがリポートされた場合は安心してCIをfailにできます．
go vet に検出されたエラーはほぼ100%直したほうがよいでしょう．</p>

<h3>golint</h3>

<ul>
<li><a href="https://github.com/golang/lint">golang/lint: This is a linter for Go source code.</a></li>
<li>おすすめ度: ★★★★☆</li>
</ul>


<blockquote><p>Golint differs from gofmt. Gofmt reformats Go source code, whereas golint prints out style mistakes.
Golint differs from govet. Govet is concerned with correctness, whereas golint is concerned with coding style.</p></blockquote>

<p>gofmtがコードのリフォーマットを，govetがコードの正確性をチェックするのに対して，golint
は Go のソースコードの <strong>&ldquo;コーディングスタイル&rdquo;</strong>
の問題を報告します．これはエラーというよりも &ldquo;suggestion&rdquo; に近く，
基本的に従っていたほうがGoの慣習に沿った確実によいコードになるのですが，
まれに，いやここの関数はコメント書かなくても絶対いいよね&hellip;とかいうケースもあり
若干消耗することもあるので星4です．</p>

<p>なお，結局はコーディングスタイルの問題をリポートするという思想からデフォルトでは問題があっても
exit code は 0 になるので，落としたい場合は <code>-set_exit_status</code> flag を付けましょう．</p>

<h3>errcheck</h3>

<ul>
<li><a href="https://github.com/kisielk/errcheck">kisielk/errcheck: errcheck checks that you checked errors.</a></li>
<li>おすすめ度: ★★★☆☆</li>
</ul>


<p>errcheck は関数のエラーの返り値をハンドリングチェックしているかどうかを静的に解析してくれるツールです．
エラーを捨てた状態の場合思わぬ動作(nilになってたりだとか)するので，これをチェックしてくれるのは大変嬉しいです．</p>

<p>ただし，少し実際直さなくてもいいという意味でのfalse positive が多くCIで動かすには工夫が必要で星3です．エラーをチェックしてくれるという便利度は満点．
なお，最近は標準ライブラリで必ずエラーがnilとして返ってくるような関数についてはリポートしないという
false positive を減らす工夫もされているようです．</p>

<h3>staticcheck</h3>

<ul>
<li><a href="https://github.com/dominikh/go-staticcheck">dominikh/go-staticcheck: Staticcheck is go vet on steroids, applying a ton of static analysis checks you might be used to from tools like ReSharper for C#</a></li>
<li>おすすめ度: ★★★★★</li>
</ul>


<p>staticcheck は一言で言うとサードパーティーの <code>go vet</code>です．go vet でチェックされていないようなことを静的に解析してくれます．
(例えば正規表現がvalidかチェックしてくれるかなどなど&hellip;たくさん項目があるのでREADMEを見てみてください．)</p>

<p>作者の <a href="https://github.com/dominikh">dominikh さん</a> は Go
言語の開発にも関わっていて，dominikh さん製Go lint ツールは個人的には
信頼できる印象です．github/go の issue でも  go vet のissueなどに， staticcheck
は実際こういうのチェックしてるけどと言った感じで参照されてたりするのを見かけます．</p>

<p>そして次の2つのツールも dominikh さん製です．</p>

<h3>gosimple</h3>

<ul>
<li><a href="https://github.com/dominikh/go-simple">dominikh/go-simple: Gosimple is a linter for Go source code that specialises on simplifying code</a></li>
<li>おすすめ度: ★★★★★</li>
</ul>


<p>gosimple は一言で言うとdominikh さん製のサードパーティー <code>gofmt -s</code> です．もっとコードをシンプルに出来るところを報告してくれます．
(ただし執筆時現在，自動で修正してくれるオプションとかはない)</p>

<p>例えば <code>if err != nil { return err }; return nil</code> といった構造のコードがあれば
<code>return err</code> で十分だよ? と報告してくれます．</p>

<p>報告に false positive もない印象で，あーそんなメソッドあったのか〜ということに気付いたりできてオススメです．</p>

<h3>go-unused</h3>

<ul>
<li><a href="https://github.com/dominikh/go-unused">dominikh/go-unused: Check Go programs for unused identifiers</a></li>
<li>おすすめ度: ★★★★★</li>
</ul>


<p>使ってない identifier をチェックしてくれます．
Go のコンパイラ自体が使ってない変数があるとコンパイル通らないという話もありますが，
unused は グローバル変数の var や const, struct の field，export されていない関数などで
使われていないものを報告してくれます．</p>

<p>報告してくれないのは使われてない関数の引数くらいでしょうか? これはインターフェースを満たすための関数など，
引数もらうけど使わないんやというケースなどを考えて報告されていないのではないかという気がします．[要出典]</p>

<p>また個人的には使えてないので強くオススメできませんが，パッケージのリストを渡して
exported なもので，渡したパッケージ内で使われていないものをチェック出来る機能もあります．
<a href="https://github.com/dominikh/go-unused#whole-program-analysis">https://github.com/dominikh/go-unused#whole-program-analysis</a>
&ldquo;internal&rdquo; packages などを使っていたりする場合は便利かもしれないですね．</p>

<p>unused は個人的には大変便利に使っていて，ごくまれにデバック用のexportしてない関数を報告されて，
あー&hellip;ってなる以外に false positive な結果もなく便利に使っています．</p>

<p>この前 interface を満たすためのダミーの関数をいろんな struct に定義してたんですが，
その際，追加すべきでない struct にも追加してしまい，それを unused が<a href="https://github.com/haya14busa/go-vimlparser/pull/23#pullrequestreview-11276693">報告</a>
してくれたことがありました．インターフェースを満たすかどうかといった観点での&#8221;used&#8221;もちゃんと見てくれていて大変良い子だな〜と思い感動しました．
オススメです．</p>

<h3>gofmt -s</h3>

<ul>
<li><a href="https://golang.org/cmd/gofmt/">gofmt - The Go Programming Language</a></li>
<li>おすすめ度: ★★★★☆</li>
</ul>


<p>linter ではない若干番外編その1．</p>

<p><code>gofmt -s</code> の結果 diff があるかどうか，つまりもっとシンプルにかけた部分がないかということをチェックできます．</p>

<p>コマンド: <code>(! gofmt -s -d . | grep '^')</code></p>

<p>括弧は travis などのyamlでvalidなものにするために使っています．
gofmt も exit code が 1 になったりすることはないので個人的には <code>grep '^'</code>
の結果を否定することによって，diffを表示しつつ，diffがあればfailにするという手法を使っています．
(<code>xargs -r</code> とかはMacでは<code>-r</code>がないとかがある&hellip;)</p>

<p>基本的にGo言語開発時はみんな gofmt かけていると思いますが，<code>-s</code> は付けていなかったり，
<code>goimport</code> で <code>gofmt</code> を代用していた場合に <code>-s</code> オプションがなくてかけてなかったりするので
CI で実行するとちょっと便利です．</p>

<p>ちょっと便利なんですが，<code>-s</code> つけるとめっちゃシンプルになって絶対いいよね&hellip;! というよりは，
あー手元で実行してなくて，CIサーバでdiffでちゃったよ&hellip;直すか&hellip;とちょ〜っとだけ消耗することが
あるという意味で個人的にはオススメ度星4です．(goimport <code>-s</code>フラグ足してくれ〜)</p>

<h3>go test -race</h3>

<ul>
<li>おすすめ度: ★★★★★</li>
</ul>


<p>linter ではない若干番外編その2．
<code>go test</code> に <code>-race</code> を付けるとrace condition があるかチェックしてくれます．
特に goroutine とか使ってるコードであれば，CIでのテスト実行時にはぜひ付けておくべきでしょう．
僕も何度も<code>-race</code>に怒られてコード直したり，ああここlockいるなと気付かされております．</p>

<h3>その他</h3>

<p>あんまり僕がまだ使えてなくて，ちゃんとオススメできないけど便利な静的チェックツールはいくつかあります．</p>

<h4>interfacer</h4>

<ul>
<li><a href="https://github.com/mvdan/interfacer">https://github.com/mvdan/interfacer</a></li>
<li>引数の型とかインターフェースでいいじゃん?というところを指摘してくれる. e.g. <code>*os.File</code> -> <code>io.Reader</code></li>
<li>個人的にはインターフェースにするといいところは最初からインターフェース使ってたりするしそこまでの恩恵は感じない</li>
</ul>


<h4>gosum</h4>

<ul>
<li><a href="https://github.com/haya14busa/gosum">https://github.com/haya14busa/gosum</a></li>
<li>急に拙作ツールの宣伝(?)</li>
<li>Go のインターフェースで直和型っぽいことを表現したときの，type switch に抜け漏れがないかを静的にチェックするツールです．</li>
<li>Scala でいう sealed trait のパターンマッチでコンパイラが抜け漏れがあると warning だしてくれるというやつのGoバージョン</li>
<li>詳しくはこの記事に書きました ->  <a href="https://medium.com/@haya14busa/sum-union-variant-type-in-go-and-static-check-tool-of-switch-case-handling-3bfc61618b1e#.lh90e9kx1">Sum/Union/Variant Type in Go and Static Check Tool of switch-case handling – Medium</a></li>
<li>書いてみて，使ってみて実際便利だと思ってるんですが，まだちゃんとCIで回したりはしてないので，その他枠で雑に紹介です．</li>
</ul>


<p>ところで linter 書くときって，AST ベースで解析するツールが僕の観測範囲では多いと思うですが，
Goは必要であれば <a href="https://golang.org/pkg/go/types/">go/types</a> パッケージを使って型情報まで使って
解析できるので大変便利ですね&hellip;! 標準ライブラリでカバーされてるところも +1</p>

<p><strong>&ldquo;go/ast ではしゃいでるのはもう古い! 時代は go/types !&rdquo;</strong> みたいな煽りタイトルの解説記事を最近は待ち望んでます．
go/types 関連は標準ライブラリの中でもかなり大きいものなのでなかなか僕もまだ全貌を理解できてないです．</p>

<h4>その他のその他</h4>

<p><a href="https://github.com/alecthomas/gometalinter">gometalinter</a> とか <a href="https://goreportcard.com/report/github.com/haya14busa/reviewdog">Go Report Card</a> で紹介されているツール．</p>

<p><a href="https://github.com/fzipp/gocyclo">https://github.com/fzipp/gocyclo</a>
とかイマイチ恩恵を受けたことがないんですが，gometalinter とか <a href="https://goreportcard.com/report/github.com/haya14busa/reviewdog">Go Report Card</a>
で使われているツールは参考になるかもしれません．</p>

<h2>reviewdog: linter の false positive と闘う</h2>

<p>特に golint や errcheck など，上記でオススメしたlinterの中には，false positive
なリポートが結構あって，めっちゃ便利でチェックしたいんだけど CI で fail
にしづらい&hellip; というものがいくつかあります．</p>

<p>そこで拙作ツール <a href="https://github.com/haya14busa/reviewdog">reviewdog</a> の紹介です．(宣伝)</p>

<p>もちろん Go 製です!</p>

<p><a href="https://github.com/haya14busa/reviewdog/pull/63#pullrequestreview-13287340"><img src="../images/post/2016-12-26-reviewdog.png" alt="" /></a></p>

<p>(画像は実際のPull Requestのコメントへのリンクになってます)</p>

<p>reviewdog は Go 言語の linter に限らず，任意のコマンドの結果を&#8217;errorformat&#8217;
という形式を使うことでパースして，<em>diff</em> で新たに追加された部分にたいする問題だけを
表示したり，GitHub にコメントすることが出来るツールです． 詳しくは -> <a href="http://haya14busa.com/reviewdog/">reviewdog を飼ってコードレビューや開発を改善しませんか - haya14busa</a></p>

<p>結果をdiffでフィルターすれば，それらの問題についてのみPull
Requestのレビュー時やコミット時にチェックすることが出来るので，
もし false positive な結果な場合は単に無視すれば次回以降に同じ問題は報告されません．</p>

<p>もちろん，例えば先に紹介した unused などは全然diffと関係ない部分で新たに問題がおきたりすることもあり，
結果を diff でフィルターするというのはfalse positiveと闘う銀の弾丸ではないのですが，
多くの場合これで十分機能を果たすでしょう．
(一応 diff 外の問題もうまくまとめて報告する仕組みも足したいな〜という気持ちはあります)</p>

<p>Go 製ツールである reviewdog は自分自身のコードでドックフーディングしていて，この記事で紹介した
いろんなGo 用 linter を実行していて，上記の画像のように実際に便利に使っています．
参考: <a href="https://github.com/haya14busa/reviewdog/blob/08050fc886b39f7caa4b0f39bcb2188043030214/reviewdog.yml">reviewdog/reviewdog.yml</a>
(最近はyamlでも管理できるようにしていて，より簡単にローカルで実行したり，git hook で実行しやすくしたりしたいなどと改善しています)</p>

<h2>Goのテストカバレッジをレビューでも活用する</h2>

<p>Go は標準で <code>go test -coverprofile=coverage.out .</code> などと実行するとテストカバレッジを取得することができます．
ただ実は CI などでカバレッジを取得する際は注意点があり，複数のパッケージをまとめてカバレッジを計測することはできません．
つまり例えば <code>go test -coverprofile=coverage.out ./...</code> とはできません．これは
<code>go test</code> 内部ではパッケージごとにテスト実行用バイナリを作成してそれぞれ実行してるという設計になっていることに起因します．
<a href="https://github.com/golang/go/issues/6909#issuecomment-233493644">issue</a> は上がってますが標準では対応するのはなかなか骨が折れそうです．
(ちょっと修正してコントリビューションしてみようかと格闘しましたが構造的に地味に大変そうでした&hellip;)</p>

<p>そこで現状で，複数パッケージのテストカバレッジに対応するために色んな所で Makefile やGoのツールを使うといった解決方法が紹介されています．
しかし!紹介されていて，確かにある程度はどれも動くのですが，実は多くのスクリプトはちょっと片手落ちなものになっています．
例えば go test の <code>-coverpkg</code> 引数を使わないと依存先のコードカバレッジが取得できてなかったり，
結果の coverage.out に重複行が生まれるケースがあったりします．</p>

<h3>解決策</h3>

<p>mattn さんの <a href="https://github.com/mattn/goveralls">mattn/goveralls</a>
では上記の問題に対応したマルチパッケージ対応テストカバレッジ機能が備わっています．というか僕がPull Request しました．
<a href="https://coveralls.io/">Coveralls</a> に投稿する場合は goveralls を使うと良いと思います.  (<code>goveralls -service=travis-ci</code> でよしなにやってくれる)</p>

<h3>ローカルでは?</h3>

<p>goveralls にコントリビューションしたあと，あれ&hellip;これローカルでもやりたいじゃん&hellip;ということに気付き，
既存のMakefileソリューションや似たツールはいくつかあるにはあったんですが，上記の問題などの対応とか
いろいろ面倒だったのでマルチパッケージカバレッジ作成用go test のラッパーツールを作りました．</p>

<p><a href="https://github.com/haya14busa/goverage">haya14busa/goverage: go test -coverprofile for multiple packages</a></p>

<pre><code>$ goverage -coverprofile=coverage.out ./...
</code></pre>

<p>とかするといい感じに coverage.out が生成されます．便利．</p>

<h3>codecov に投稿してレビューでも活用する - &ldquo;おい、coverall もいいけど codecov 使えよ&rdquo;</h3>

<p>サブタイは <a href="https://twitter.com/b4b4r07">b4b4r07</a> さんリスペクトです． ref: <a href="http://qiita.com/b4b4r07/items/9e1bbffb1be70b6ce033">おい、peco もいいけど fzf 使えよ - Qiita</a></p>

<p><a href="https://codecov.io/">Codecov</a> という <a href="https://coveralls.io/">Coveralls</a> と似たサービスがあるのはご存知でしょうか?
僕は以前からたまに見かけたことはあったのですが，最近はじめて使ってみて，断然 coverall よりいいじゃん&hellip;!!! と感じました．</p>

<p>全体的に洗練されてる&hellip;というよさもあるんですが，一番いいところは Pull Request の diff に対するカバレッジを表示できて，
ブラウザの拡張をインストールすれば GitHub の Pull Request 画面上でカバーされた行をオーバーレイで確認できるところが大変気に入りました．</p>

<p><a href="https://github.com/haya14busa/reviewdog/pull/63#pullrequestreview-13287340"><img src="../images/post/2016-12-26-codecov-pull-request.png" alt="" /></a></p>

<p>もちろん Codecov 上のページでも見れます: <a href="https://codecov.io/gh/haya14busa/reviewdog/pull/63/compare">Compare ⋅ haya14busa/reviewdog</a></p>

<p>Go 言語リポジトリのカバレッジを travis で計測して codecov へ投稿する例:</p>

<pre><code># .travis.yml
install:
  - go get github.com/haya14busa/goverage

script:
  - goverage -coverprofile=coverage.txt ./...

after_success:
  - goveralls -service=travis-ci -coverprofile=coverage.txt
  - bash &lt;(curl -s https://codecov.io/bash)
</code></pre>

<p><a href="https://github.com/codecov/example-go#caveat-multiple-files">codecov 公式のGo言語用リポジトリの例</a> では Makefile を使ってますが，
完全に上記のマルチパッケージサポートの問題を踏んでるので <code>goverage</code> を使うと良いと思います．</p>

<p>テストカバレッジは別に100%を目指さなくてもよいと思っていて，全体のカバレッジが何％以下とか何％下がったらステータスをfail
にするといった機能がcoverallやcodecov にはありますが，この辺を有効にすると結構消耗するかと思います．</p>

<p>ただ，カバレッジを参考にすることは有用だし，ユニットテストは基本的に書くべきです．
Pull Request などではカバーすべきところをしっかりカバーしたテストを期待したいし，，
レビュー時にもそのあたりが可視化されると大変便利です．</p>

<p>実際僕は Go のレビューするときに手元でテストまわしてcoverageみて，ここテストそもそも無いから足して欲しいだとか，
この行はカバーされてないけど，カバーすべき部分なのでテストケース足して欲しいとか言ったりするんですが，
codecov を使うとこのフローがやりやすいし，レビュイーもPull Request を出した時点で自分で気付いて
テスト足したりできると思います．</p>

<p>実は codecov 使い始めたのは最近で，僕自身がチーム開発として使った経験はまだないのですが，
coverall よりも codecov 使うとこの辺いい感じに可視化されて人間が指摘しなくてもよくなったり，
レビュワーとして指摘しやすくなったりすると思います．</p>

<p>せっかく Go という言語は標準でテストが書きやすく，カバレッジ計測もしやすいので，ぜひ皆さんもカバレッジを計測して，codecov 使ってみてはいかがでしょうか?</p>

<h3>まとめ</h3>

<p>Go のCIでまわすと便利なlintツールを紹介したり，テストカバレッジの取得方や codecov のオススメなどをしました．
Go は <code>go/ast</code>, <code>go/types</code> など <code>go/</code> 下の標準パッケージを使ってコードをパースしてASTを取得したり，型情報を取得したりなど
するライブラリが用意されているので，必要に応じて自前でチェックツールを作ったりもしやすく面白いです．</p>

<p>この記事で紹介したものは，一般的に多く使われているみなさんが知っているようなものから，あまり知られてないものまであるかと思いますが，
すべて少なくとも僕が使っていて便利だなぁ〜，と思ったものを紹介してみました．
他に便利なオススメツールなどがあれば教えてください！</p>

<p>個人OSSプロジェクトではレビュワー最初はいない問題などがあり，最近はPull Requestを開いてlint チェックさせたり，カバレッジみたり，
改めてブラウザ画面上でセルフレビューするなどしていて，まぁちょっと面倒もあるけど良い感じです．
あとは設計レビューとかもしてくれるGoのツールがあればカンペキですね〜〜〜！！！１</p>

<p>もちろんチーム開発でのレビューでも，消耗しがちな非人間的な指摘は機械にやってもらって，
もっと大事な観点をレビューするために，この記事で各種紹介した手法は役に立つかなと思います．</p>

<p>来年も Go 書いていくぞ!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go で Vim プラグインを書く]]></title>
    <link href="http://haya14busa.com/vim-go-client/"/>
    <updated>2016-12-21T18:14:54+09:00</updated>
    <id>http://haya14busa.com/vim-go-client</id>
    <content type="html"><![CDATA[<p>この記事は <a href="http://qiita.com/advent-calendar/2016/vim">Vim アドベントカレンダー 2016</a> の21日目の記事です．</p>

<p>最近は Go 言語が大好きすぎて，Vim plugin も Go で書きたい!!! という欲が出てきたので，
Vim plugin を Go で書く方法について紹介します．</p>

<h2>Go で Vim plugin を書くとは?</h2>

<p>一口に Go で Vim plugin を書くといっても</p>

<ol>
<li>Go で書いたバイナリがメインで Vim script の autoload 関数などから呼ぶ．例: <a href="https://github.com/mattn/vim-filewatcher">https://github.com/mattn/vim-filewatcher</a></li>
<li>Go 側からも Vim script を呼ぶ，つまり Vim script で Vim の情報を取得するところなど含めて，ほぼ全部 Go で書く．</li>
</ol>


<p>という 2 段階があると思います．本記事では2の方法も含めて紹介しますがまずは1から行きましょう．</p>

<h2>1. Go で書いたバイナリをつかった Vim plugin の作り方</h2>

<p>これは先程例にあげた <a href="https://github.com/mattn/vim-filewatcher">https://github.com/mattn/vim-filewatcher</a> がシンプルでわかりやすいです．</p>

<p><a href="https://github.com/mattn/vim-filewatcher/blob/22594895e16cb4de11afa37f04d88a996f48da58/filewatcher/filewatcher.go">filewatcher/filewatcher.go</a>
で書いた Go をインストール時に <code>cd filewatcher &amp;&amp; go get -d &amp;&amp; go build</code> でビルドし，
<a href="https://github.com/mattn/vim-filewatcher/blob/22594895e16cb4de11afa37f04d88a996f48da58/autoload/filewatcher.vim">autoload/filewatcher.vim</a>
でこのバイナリを <code>job</code> をつかって呼んでいます．</p>

<p><code>go get -d</code> を呼ぶことで依存するパッケージをダウンロードし，<code>go build</code> することで <code>$GOBIN</code> などを汚さずにプラグインディレクトリにバイナリを配置できます．</p>

<h4><a href="https://github.com/mattn/vim-filewatcher/blob/22594895e16cb4de11afa37f04d88a996f48da58/autoload/filewatcher.vim">autoload/filewatcher.vim</a></h4>

<pre><code>let s:cmd = expand('&lt;sfile&gt;:h:h:gs!\\!/!') . '/filewatcher/filewatcher' . (has('win32') ? '.exe' : '')
if !filereadable(s:cmd)
  finish
endif

function! filewatcher#watch(dir, cb)
  return {'dir': a:dir, 'job': job_start([s:cmd, a:dir], { 'out_cb': a:cb, 'out_mode': 'nl' })}
endfunction
</code></pre>

<p>バイナリを呼んでいるVim script もとてもシンプルで， windows かどうか見ながらバイナリのパスを取得し，
それを <code>job</code> で呼ぶだけです．簡単．プラグインの性質によっては <code>job</code> ではなく <code>system()</code> などを使ってもよいでしょう．</p>

<p>また，開発時には <code>g:plugin_name#debug</code> などを作ってそれを見て <code>go run</code> を呼ぶというふうに変えることもできます．</p>

<pre><code>function! s:separator() abort
  return fnamemodify('.', ':p')[-1 :]
endfunction

let s:is_windows = has('win16') || has('win32') || has('win64') || has('win95')

let s:base = expand('&lt;sfile&gt;:p:h:h')
let s:basecmd = s:base . s:separator() . fnamemodify(s:base, ':t')
let s:cmd = s:basecmd . (s:is_windows ? '.exe' : '')

if g:plugin_name#debug
  let s:cmd = ['go', 'run', s:basecmd . '.go']
elseif !filereadable(s:cmd)
  call system(printf('cd %s &amp;&amp; go get -d &amp;&amp; go build', s:base))
endif
</code></pre>

<p>僕が作ったプラグインから引っ張ってきた例で autoload/filewatcher.vim ほどシンプルではないですが，もうちょっとなんとか出来るかもしれないですね．
main パッケージのファイル (<code>s:basecmd . '.go'</code>) を1ファイルにすると<code>go run</code>で呼びやすいです．</p>

<h2>2. Go 側からも Vim script を呼ぶ必要があるようなプラグインの作り方</h2>

<p>mattn/filewatcher ではファイルの変更を検知してstdout にJSONを吐いて，それが job の callback に渡されるという形式で単体で簡潔してましたが，
場合によっては Go 側から Vim の状態を取得したり，Vim script を呼んだりしたい場合もあります．
そういうプラグインを作るには，job を JSON モードで起動し， <a href="http://vim-jp.org/vimdoc-ja/channel.html#channel-commands">:h channel-commands</a>
を使うことによって実現できます．</p>

<h4><a href="http://vim-jp.org/vimdoc-ja/channel.html#channel-commands">:h channel-commands</a></h4>

<pre><code>JSON チャンネルを使用すると、サーバープロセス側はVimへコマンドを送信できます。
そのコマンドはチャンネルのハンドラーを介さずに、Vimの内部で実行されます。

実行可能なコマンドは以下のとおりです:           *E903* *E904* *E905*
    ["redraw", {forced}]
    ["ex",     {Ex コマンド}]
    ["normal", {ノーマルモードコマンド}]
    ["eval",   {式}, {数値}]
    ["expr",   {式}]
    ["call",   {func name}, {argument list}, {number}]
    ["call",   {func name}, {argument list}]
</code></pre>

<p><code>{数値}</code>(<code>{number}</code>) は id で，job -> Vim に渡すさいはマイナスを指定する必要があり，
その渡した id と共に評価された値が返ってきます．</p>

<p>例えば Go 側で stdout に <code>["expr","line('$')", -2]</code> を書き込むと， Vim
が<code>line('$')</code> を評価してその結果が stdin に <code>[-2, "last line"]</code>
といった結果が返ってきます．</p>

<p>便利すぎる&hellip;</p>

<p>ということでidの取扱などこのあたりの処理を毎回丁寧にやるのは面倒くさいので，
<a href="https://github.com/haya14busa/vim-go-client">https://github.com/haya14busa/vim-go-client</a> というラッパーを作りました．
ドキュメント: <a href="https://godoc.org/github.com/haya14busa/vim-go-client#Client">https://godoc.org/github.com/haya14busa/vim-go-client#Client</a></p>

<p><a href="https://godoc.org/github.com/haya14busa/vim-go-client#Client"><code>type Client</code></a> が上記の channel-commands などのに相当するメソッドを持っており，
<a href="https://godoc.org/github.com/haya14busa/vim-go-client#Handler"><code>type Handler</code></a> がメッセージの受け渡しを担当します．</p>

<p>サンプル: <a href="https://github.com/haya14busa/vim-go-client/blob/32a96bf256fabc81dff549a70328a6bb3f24e9b5/_example/dev/job/job.go"><code>_example/dev/job/job.go</code></a></p>

<pre><code>package main

import (
    "fmt"
    "log"
    "os"
    "time"

    vim "github.com/haya14busa/vim-go-client"
)

type myHandler struct{}

func (h *myHandler) Serve(cli *vim.Client, msg *vim.Message) {
    log.Printf("receive: %#v", msg)
    if msg.MsgID &gt; 0 {

        if msg.Body == "hi" {
            cli.Send(&amp;vim.Message{
                MsgID: msg.MsgID,
                Body:  "hi how are you?",
            })
        } else {
            start := time.Now()
            log.Println(cli.Expr("eval(join(range(10), '+'))"))
            log.Printf("cli.Expr: finished in %v", time.Now().Sub(start))
        }

    }
}

func main() {
    handler := &amp;myHandler{}
    cli := vim.NewClient(vim.NewReadWriter(os.Stdin, os.Stdout), handler)
    done := make(chan error, 1)
    go func() {
        done &lt;- cli.Start()
    }()

    cli.Ex("echom 'hi'")
    log.Println(cli.Expr("1+1"))

    select {
    case err := &lt;-done:
        fmt.Printf("exit with error: %v\n", err)
        fmt.Println("bye;)")
    }
}
</code></pre>

<p><code>handler := &amp;myHandler{}</code> でハンドラを作って <code>cli := vim.NewClient(vim.NewReadWriter(os.Stdin, os.Stdout), handler)</code>
で stdin/stdout を介してVim と通信できるclientを作成しています．
あとはこいつを <code>cli.Start()</code> しておけば Vim から <code>ch_sendexpr()</code> などが呼ばれると handler に中身が渡されるし，
<code>cli.Ex("echom 'hi'")</code> などを呼ぶと Vim 側で <code>echom 'hi'</code> が実行されます．</p>

<h2>実例: vim-stacktrace</h2>

<p>実際に vim-go-client を使ってひとつプラグインを書いてみました．</p>

<p><a href="https://github.com/haya14busa/vim-stacktrace">haya14busa/vim-stacktrace</a></p>

<p><img src="https://raw.githubusercontent.com/haya14busa/i/e7ef65e590e850ea37425c6ebf4479c1422ef8c8/vim-stacktrace/stacktracefromhist.gif" alt="stacktracefromhist.gif (1287×800)" /></p>

<p>Vim のスタックトレースをquickfix に流し込むプラグインでやっていることとしては6日目の記事の <a href="http://qiita.com/tmsanrinsha/items/0787352360997c387e84">Vim scriptのエラーメッセージをパースしてquickfixに表示する - Qiita</a>
と近いです．</p>

<p>autoload 関数からjobに <code>ch_evalexpr</code>
する部分([link]<a href="https://github.com/haya14busa/vim-stacktrace/blob/933f9d10c7ef99467c27609fcdd80be37c0712e8/autoload/stacktrace.vim#L12-L30">https://github.com/haya14busa/vim-stacktrace/blob/933f9d10c7ef99467c27609fcdd80be37c0712e8/autoload/stacktrace.vim#L12-L30</a>())
を除いてほぼ全てがGoで実装されていて，現時点で Go の割合が 87.8 % です．</p>

<p><img src="https://cloud.githubusercontent.com/assets/3797062/21386073/5e56a5aa-c7b4-11e6-9cac-869cbb8ffe8d.png" alt="image" /></p>

<p>実装の中身としても，Vim のスタックトレースからは関数内における行番号しかとれず，ファイルの行番号が取得できない問題があるのですが，
それをGoで実装したVim script parser (<a href="https://github.com/haya14busa/go-vimlparser">https://github.com/haya14busa/go-vimlparser</a>) を使ってファイルをパースし，行番号を取得することができています．
また，<code>:CStacktraceFromhist</code> などは Vim script の <code>inputlist</code> をGo側から呼んでいてインテラクティブにVimと協調して動作できることも示せました．</p>

<h2>Go で書くよさ</h2>

<p>実際に Vim script でやっているひともいたように，vim-stacktrace は Go
が無いとかけなかったといった類のものではないですが，Goで書くといいことがたくさんありました．</p>

<ul>
<li>型がある安心感</li>
<li>テストが標準に備わっていて書きやすい (go test)</li>
<li>カバレッジも取れる! (go test -coverprofile)</li>
<li>Go のパッケージが使える (go-vimlparser, etc&hellip;)</li>
<li>etc&hellip;</li>
</ul>


<p>カバレッジなどは現在Vim scriptのテスティングフレームワークではサポートされていないし，なかなか実装しようとしてもムズカシそうなのですが，
Goでかけば標準でついてきます．とても便利．</p>

<p>coverall も使えます: <a href="https://coveralls.io/github/haya14busa/vim-stacktrace?branch=master"><img src="https://coveralls.io/repos/github/haya14busa/vim-stacktrace/badge.svg?branch=master" alt="Coverage Status" /></a></p>

<p>逆にPure Vim script と比較して悪いところや注意点があるとすれば</p>

<ul>
<li>vim-go-client がまだ安定してない</li>
<li>channel-commands がエラーをちゃんと返してくれない(エラーがあれば &ldquo;ERROR&rdquo; とだけ返ってくる)</li>
<li>チャンネルの通信で少しだけオーバーヘッドがある</li>
<li>現状vim/neovimに両対応できない</li>
</ul>


<p>といった感じでしょうか．もうちょっとvim-go-client精錬させたいですね&hellip;頑張ります&hellip;</p>

<h2>NeoVim のリモートプラグイン</h2>

<p>neovim 向けには実は <a href="https://github.com/neovim/go-client">neovim/go-client</a> というものが存在し，リモートプラグインをGoで書くことが出来るようです．</p>

<p><a href="http://vimconf.vim-jp.org/2016/">Vimconf 2016</a> で <a href="https://github.com/zchee">zchee</a> さんが発表していた nvim-go はこれが使われています．</p>

<p>スライド該当部分: <a href="http://go-talks.appspot.com/github.com/zchee/talks/vimconf2016.slide#33">http://go-talks.appspot.com/github.com/zchee/talks/vimconf2016.slide#33</a></p>

<p>正直なところ neovim のリモートプラグインの先行アドバンテージ(?)は大きく，vim-go-client と比較してかなり高機能になってます．
理想としては Vim 8 でも neovim でも使えるものをかけるようにしたいのですが， neovimのリモートプラグインが高機能であることや，
msgpack 依存であることからなかなか両方に対応することはムズカシイです&hellip;</p>

<p>うまく抽象化してロジックの部分だけ共通化して，vim8用/neovim用にメッセージのハンドラを管理してうんたん&hellip;みたいなことは出来るかも知れないので，
今後の研究課題という感じですね．あと僕がほとんどneovim使わないので nvim-go の仕様感とか知っている方はお話してくれると嬉しいです．
(Vimconf で zchee さんとその話ができたのは便利だった&hellip;)</p>

<h2>おわりに</h2>

<p>正直まだまだGoで書かれたVim plugin は少なく発展途上ですが，実用的なプラグインを作成することもできたので，可能性を感じます．
Go でかけばマルチプラットフォームに対応できるし，ライブラリがどうとか環境がどうとか気にすることなく動かせるので，Vim との親和性はかなり高いと思っています．</p>

<p>何よりGoはかわいい!書いていて楽しい!</p>

<p>まだまだ発展途上ですが，ぜひ皆さんもGoでVim プラグインを作ってみてください．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golangにおけるinterfaceをつかったテストで mock を書く技法]]></title>
    <link href="http://haya14busa.com/golang-how-to-write-mock-of-interface-for-testing/"/>
    <updated>2016-11-02T07:19:14+09:00</updated>
    <id>http://haya14busa.com/golang-how-to-write-mock-of-interface-for-testing</id>
    <content type="html"><![CDATA[<p>いい記事に感化されて僕も何か書きたくなった。</p>

<p><a href="http://deeeet.com/writing/2016/10/25/go-interface-testing/">Golangにおけるinterfaceをつかったテスト技法 | SOTA</a></p>

<p>リスペクト:</p>

<ul>
<li><a href="http://mattn.kaoriya.net/software/lang/go/20161025113154.htm">Big Sky :: golang で終了を確認するテストの書き方</a></li>
<li><a href="http://deeeet.com/writing/2016/11/01/go-api-client/">GolangでAPI Clientを実装する | SOTA</a></li>
<li><a href="http://mattn.kaoriya.net/software/lang/go/20161101151118.htm">Big Sky :: GolangでAPI Clientを実装する、の続き</a></li>
</ul>


<p>今週のやつではなく先週のです．今週のは特に知見がなかった&hellip;<a href="https://github.com/grpc/grpc-go">grpc-go</a>とか使えたらクライアント勝手に生成されるしいいよねgrpc流行ると便利そう(感想) くらい</p>

<p><a href="http://deeeet.com/writing/2016/10/25/go-interface-testing/">Golangにおけるinterfaceをつかったテスト技法 | SOTA</a>
めっちゃいいなーと思ったんですが，テスト用 の mock を気軽に作るテクニックはあまり詳しく紹介されてなかったのでそのあたりの１つのテクニックを書きたい．</p>

<h2>前提</h2>

<p>僕もテストフレームワークや外部ツールは全く使わない．標準のtestingパッケージのみを使う．
<a href="https://github.com/stretchr/testify">testify</a> もいらないし， mock するために <a href="https://github.com/golang/mock">gomock</a> も基本はいらない．</p>

<p>とにかくGolangだけで書くのが気持ちがいい，に尽きる．</p>

<h2>テスト用 fake client をつくる</h2>

<p>全体の動くはずのgist: <a href="https://gist.github.com/haya14busa/27a12284ad74477a6fd6ed66d0d153ee">https://gist.github.com/haya14busa/27a12284ad74477a6fd6ed66d0d153ee</a></p>

<p>例えばこういう実装のテストを書くときのことを考えます．</p>

<pre><code>package main

import (
    "context"
    "fmt"
)

type GitHub interface {
    CreateRelease(ctx context.Context, opt *Option) (string, error)
    GetRelease(ctx context.Context, tag string) (string, error)
    DeleteRelease(ctx context.Context, releaseID int) error
}

type GhRelease struct {
    c GitHub
}

func (ghr *GhRelease) CreateNewRelease(ctx context.Context) (*Release, error) {
    tag, err := ghr.c.CreateRelease(ctx, nil)
    if err != nil {
        return nil, fmt.Errorf("failed to create release: %v", err)
    }

    // check created release
    if _, err := ghr.c.GetRelease(ctx, tag); err != nil {
        return nil, fmt.Errorf("failed to get created release: %v", err)
    }

    // ...
    return &amp;Release{}, nil
}

type Option struct{}
type Release struct{}
</code></pre>

<p>GitHub interface をテストでは mock したものを使いたい．そういうときには以下のように mock を作ると便利です．</p>

<pre><code>type fakeGitHub struct {
    // インターフェース埋め込み
    GitHub
    FakeCreateRelease func(ctx context.Context, opt *Option) (string, error)
    FakeGetRelease    func(ctx context.Context, tag string) (string, error)
    // 埋め込みを使うので，例えば DeleteRelease はまだテストしないので mock
    // しない... いうことができる．
}

func (c *fakeGitHub) CreateRelease(ctx context.Context, opt *Option) (string, error) {
    return c.FakeCreateRelease(ctx, opt)
}

func (c *fakeGitHub) GetRelease(ctx context.Context, tag string) (string, error) {
    return c.FakeGetRelease(ctx, tag)
}
</code></pre>

<p><code>fakeGitHub</code> という struct を作成し，インターフェースをとにかく満たすために <code>GitHub</code>
interface を埋め込みます．</p>

<p>そして mock したいメソッドは新たに <code>func (c *fakeGitHub) CreateRelease(...) (...)</code> と
定義しなおし，実装の中身は <code>fakeGitHub</code> に持たせた <code>FakeCreateRelease</code> field に丸投げします．</p>

<p>このようにしてテスト用 mock を作るとそれぞれのテストで簡単に中身の実装を変えられるので大変便利です．</p>

<p>実際にテストしてみる例</p>

<h4>main_test.go</h4>

<pre><code>package main

import (
    "context"
    "fmt"
    "testing"
)

type fakeGitHub struct {
    // インターフェース埋め込み
    GitHub
    FakeCreateRelease func(ctx context.Context, opt *Option) (string, error)
    FakeGetRelease    func(ctx context.Context, tag string) (string, error)
    // 埋め込みを使うので，例えば DeleteRelease はまだテストしないので mock
    // しない... いうことができる．
}

func (c *fakeGitHub) CreateRelease(ctx context.Context, opt *Option) (string, error) {
    return c.FakeCreateRelease(ctx, opt)
}

func (c *fakeGitHub) GetRelease(ctx context.Context, tag string) (string, error) {
    return c.FakeGetRelease(ctx, tag)
}

func TestGhRelease_CreateNewRelease(t *testing.T) {
    fakeclient := &amp;fakeGitHub{
        FakeCreateRelease: func(ctx context.Context, opt *Option) (string, error) {
            return "v1.0", nil
        },
        FakeGetRelease: func(ctx context.Context, tag string) (string, error) {
            return "", fmt.Errorf("failed to get %v release!", tag)
        },
    }

    ghr := &amp;GhRelease{c: fakeclient}

    release, err := ghr.CreateNewRelease(context.Background())
    if err != nil {
        t.Error(err)
        // =&gt; failed to get created release: failed to get v1.0 release!
    }
    _ = release
    // ...
}
</code></pre>

<p>以下のような感じで，簡単にテスト用mockの実装を書いて，テストすることができます．</p>

<pre><code>    fakeclient := &amp;fakeGitHub{
        FakeCreateRelease: func(ctx context.Context, opt *Option) (string, error) {
            return "v1.0", nil
        },
        FakeGetRelease: func(ctx context.Context, tag string) (string, error) {
            return "", fmt.Errorf("failed to get %v release!", tag)
        },
    }
</code></pre>

<p>上記の例では1種類の実装しかテストしてないのであまり恩恵がわかりづらいかも知れないですが，
例えば error が帰ってきたときに正しくエラーハンドリングできてるかとか，
返り値をいろいろ変えたものをいくつか作ってテストする&hellip;といったことが上記のパターンを
使うことによって簡単にできます．Table Testing することも可能．</p>

<p>普通にわざわざstructごと作っていると，例えばテストの関数ないでは struct の method (e.g. <code>func (c *client) Func()</code>)
を定義することができません．</p>

<p>そこで <code>FakeFunc func()</code> というfield を持たせて実装を丸投げすることによって，
簡単にいろんな実装のテスト用 mock を作成してテストができるということの紹介でした．</p>

<h2>まとめ</h2>

<p>僕は最初にこのパターンを教わってなるほどなぁ&hellip;と思ったんですが，いざ世にでてみると(?)
ぜんぜんこのパターンを紹介しているものが見つからなかったので紹介してみました．
(一応どっかの medium の英語記事にこれに似たパターンが紹介されてたのを見た気もする&hellip;)</p>

<p>ぜひ使ってみてください．</p>

<h2>あまり関係ない追記</h2>

<p>この記事の主旨とは関係ないけど，基本的にテスト用ライブラリは使わないとはいえ，
たまににヘルパー関数ほしいなーというケースがあります．</p>

<p>でかい struct をテストで比較するときに，比較自体は <code>reflect.DeepEqual</code> で出来るのだけど，
もし違っていたときにどこが違うかを表示するのが面倒くさいのでヘルパー関数提供してくれるライブラリがほしい&hellip;</p>

<p>某社でgoのテスト書いてたときもこういう大きめのstruct比較するケースでは便利diff表示用ライブラリを
使っていた気がしたんだけど，なんかOSSで見つからない気がする&hellip; prettycmp みたいな名前だった気がするが
どうだったか&hellip; そもそも記憶違いな気もする&hellip;</p>

<p>追記: twitter で教えてもらいましたが <a href="https://github.com/kylelemons/godebug">https://github.com/kylelemons/godebug</a> っぽいです．
便利. <a href="https://godoc.org/github.com/kylelemons/godebug/pretty#Compare">https://godoc.org/github.com/kylelemons/godebug/pretty#Compare</a></p>
]]></content>
  </entry>
  
</feed>
