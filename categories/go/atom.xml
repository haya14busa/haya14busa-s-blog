<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: go | haya14busa]]></title>
  <link href="http://haya14busa.com/categories/go/atom.xml" rel="self"/>
  <link href="http://haya14busa.com/"/>
  <updated>2016-11-02T09:06:06+09:00</updated>
  <id>http://haya14busa.com/</id>
  <author>
    <name><![CDATA[haya14busa]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Golangにおけるinterfaceをつかったテストで mock を書く技法]]></title>
    <link href="http://haya14busa.com/golang-how-to-write-mock-of-interface-for-testing/"/>
    <updated>2016-11-02T07:19:14+09:00</updated>
    <id>http://haya14busa.com/golang-how-to-write-mock-of-interface-for-testing</id>
    <content type="html"><![CDATA[<p>いい記事に感化されて僕も何か書きたくなった。</p>

<p><a href="http://deeeet.com/writing/2016/10/25/go-interface-testing/">Golangにおけるinterfaceをつかったテスト技法 | SOTA</a></p>

<p>リスペクト:</p>

<ul>
<li><a href="http://mattn.kaoriya.net/software/lang/go/20161025113154.htm">Big Sky :: golang で終了を確認するテストの書き方</a></li>
<li><a href="http://deeeet.com/writing/2016/11/01/go-api-client/">GolangでAPI Clientを実装する | SOTA</a></li>
<li><a href="http://mattn.kaoriya.net/software/lang/go/20161101151118.htm">Big Sky :: GolangでAPI Clientを実装する、の続き</a></li>
</ul>


<p>今週のやつではなく先週のです．今週のは特に知見がなかった&hellip;<a href="https://github.com/grpc/grpc-go">grpc-go</a>とか使えたらクライアント勝手に生成されるしいいよねgrpc流行ると便利そう(感想) くらい</p>

<p><a href="http://deeeet.com/writing/2016/10/25/go-interface-testing/">Golangにおけるinterfaceをつかったテスト技法 | SOTA</a>
めっちゃいいなーと思ったんですが，テスト用 の mock を気軽に作るテクニックはあまり詳しく紹介されてなかったのでそのあたりの１つのテクニックを書きたい．</p>

<h2>前提</h2>

<p>僕もテストフレームワークや外部ツールは全く使わない．標準のtestingパッケージのみを使う．
<a href="https://github.com/stretchr/testify">testify</a> もいらないし， mock するために <a href="https://github.com/golang/mock">gomock</a> も基本はいらない．</p>

<p>とにかくGolangだけで書くのが気持ちがいい，に尽きる．</p>

<h2>テスト用 fake client をつくる</h2>

<p>全体の動くはずのgist: <a href="https://gist.github.com/haya14busa/27a12284ad74477a6fd6ed66d0d153ee">https://gist.github.com/haya14busa/27a12284ad74477a6fd6ed66d0d153ee</a></p>

<p>例えばこういう実装のテストを書くときのことを考えます．</p>

<pre><code>package main

import (
    "context"
    "fmt"
)

type GitHub interface {
    CreateRelease(ctx context.Context, opt *Option) (string, error)
    GetRelease(ctx context.Context, tag string) (string, error)
    DeleteRelease(ctx context.Context, releaseID int) error
}

type GhRelease struct {
    c GitHub
}

func (ghr *GhRelease) CreateNewRelease(ctx context.Context) (*Release, error) {
    tag, err := ghr.c.CreateRelease(ctx, nil)
    if err != nil {
        return nil, fmt.Errorf("failed to create release: %v", err)
    }

    // check created release
    if _, err := ghr.c.GetRelease(ctx, tag); err != nil {
        return nil, fmt.Errorf("failed to get created release: %v", err)
    }

    // ...
    return &amp;Release{}, nil
}

type Option struct{}
type Release struct{}
</code></pre>

<p>GitHub interface をテストでは mock したものを使いたい．そういうときには以下のように mock を作ると便利です．</p>

<pre><code>type fakeGitHub struct {
    // インターフェース埋め込み
    GitHub
    FakeCreateRelease func(ctx context.Context, opt *Option) (string, error)
    FakeGetRelease    func(ctx context.Context, tag string) (string, error)
    // 埋め込みを使うので，例えば DeleteRelease はまだテストしないので mock
    // しない... いうことができる．
}

func (c *fakeGitHub) CreateRelease(ctx context.Context, opt *Option) (string, error) {
    return c.FakeCreateRelease(ctx, opt)
}

func (c *fakeGitHub) GetRelease(ctx context.Context, tag string) (string, error) {
    return c.FakeGetRelease(ctx, tag)
}
</code></pre>

<p><code>fakeGitHub</code> という struct を作成し，インターフェースをとにかく満たすために <code>GitHub</code>
interface を埋め込みます．</p>

<p>そして mock したいメソッドは新たに <code>func (c *fakeGitHub) CreateRelease(...) (...)</code> と
定義しなおし，実装の中身は <code>fakeGitHub</code> に持たせた <code>FakeCreateRelease</code> field に丸投げします．</p>

<p>このようにしてテスト用 mock を作るとそれぞれのテストで簡単に中身の実装を変えられるので大変便利です．</p>

<p>実際にテストしてみる例</p>

<h4>main_test.go</h4>

<pre><code>package main

import (
    "context"
    "fmt"
    "testing"
)

type fakeGitHub struct {
    // インターフェース埋め込み
    GitHub
    FakeCreateRelease func(ctx context.Context, opt *Option) (string, error)
    FakeGetRelease    func(ctx context.Context, tag string) (string, error)
    // 埋め込みを使うので，例えば DeleteRelease はまだテストしないので mock
    // しない... いうことができる．
}

func (c *fakeGitHub) CreateRelease(ctx context.Context, opt *Option) (string, error) {
    return c.FakeCreateRelease(ctx, opt)
}

func (c *fakeGitHub) GetRelease(ctx context.Context, tag string) (string, error) {
    return c.FakeGetRelease(ctx, tag)
}

func TestGhRelease_CreateNewRelease(t *testing.T) {
    fakeclient := &amp;fakeGitHub{
        FakeCreateRelease: func(ctx context.Context, opt *Option) (string, error) {
            return "v1.0", nil
        },
        FakeGetRelease: func(ctx context.Context, tag string) (string, error) {
            return "", fmt.Errorf("failed to get %v release!", tag)
        },
    }

    ghr := &amp;GhRelease{c: fakeclient}

    release, err := ghr.CreateNewRelease(context.Background())
    if err != nil {
        t.Error(err)
        // =&gt; failed to get created release: failed to get v1.0 release!
    }
    _ = release
    // ...
}
</code></pre>

<p>以下のような感じで，簡単にテスト用mockの実装を書いて，テストすることができます．</p>

<pre><code>    fakeclient := &amp;fakeGitHub{
        FakeCreateRelease: func(ctx context.Context, opt *Option) (string, error) {
            return "v1.0", nil
        },
        FakeGetRelease: func(ctx context.Context, tag string) (string, error) {
            return "", fmt.Errorf("failed to get %v release!", tag)
        },
    }
</code></pre>

<p>上記の例では1種類の実装しかテストしてないのであまり恩恵がわかりづらいかも知れないですが，
例えば error が帰ってきたときに正しくエラーハンドリングできてるかとか，
返り値をいろいろ変えたものをいくつか作ってテストする&hellip;といったことが上記のパターンを
使うことによって簡単にできます．Table Testing することも可能．</p>

<p>普通にわざわざstructごと作っていると，例えばテストの関数ないでは struct の method (e.g. <code>func (c *client) Func()</code>)
を定義することができません．</p>

<p>そこで <code>FakeFunc func()</code> というfield を持たせて実装を丸投げすることによって，
簡単にいろんな実装のテスト用 mock を作成してテストができるということの紹介でした．</p>

<h2>まとめ</h2>

<p>僕は最初にこのパターンを教わってなるほどなぁ&hellip;と思ったんですが，いざ世にでてみると(?)
ぜんぜんこのパターンを紹介しているものが見つからなかったので紹介してみました．
(一応どっかの medium の英語記事にこれに似たパターンが紹介されてたのを見た気もする&hellip;)</p>

<p>ぜひ使ってみてください．</p>

<h2>あまり関係ない追記</h2>

<p>この記事の主旨とは関係ないけど，基本的にテスト用ライブラリは使わないとはいえ，
たまににヘルパー関数ほしいなーというケースがあります．</p>

<p>でかい struct をテストで比較するときに，比較自体は <code>refrect.DeepEqual</code> で出来るのだけど，
もし違っていたときにどこが違うかを表示するのが面倒くさいのでヘルパー関数提供してくれるライブラリがほしい&hellip;</p>

<p>某社でgoのテスト書いてたときもこういう大きめのstruct比較するケースでは便利diff表示用ライブラリを
使っていた気がしたんだけど，なんかOSSで見つからない気がする&hellip; prettycmp みたいな名前だった気がするが
どうだったか&hellip; そもそも記憶違いな気もする&hellip;</p>
]]></content>
  </entry>
  
</feed>
