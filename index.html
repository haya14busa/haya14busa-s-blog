
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="ja"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>haya14busa</title>
  <meta name="author" content="haya14busa">

  
  <meta name="description" content="この記事は Go (その3) Advent Calendar 2016 の24日目の記事です(代打)．
メリークリスマス! 本記事では Go 言語プロジェクトの CI で回すと便利な各種lintの紹介やカバレッジ計測の方法などなどについて紹介します． Go 言語おすすめ linter Go の &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://haya14busa.com/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="haya14busa" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-39461503-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'stats.g.doubleclick.net/dc.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body >
  <div id="container">
    <header role="banner"><hgroup>
  <h1><a href="/">haya14busa</a></h1>
  
    <h2>haya14busa&#8217;s memo</h2>
  
</hgroup>

</header>
    <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="site:haya14busa.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Home</a></li>
  <li><a href="/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
    <div id="main">
      <div id="content">
        <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/ci-for-go-in-end-of-2016/">Go の CI で Lint と カバレッジ回して非人間的なレビューは自動化しよう in 2016年</a></h1>
    
    
      <div class="post-meta">
        <p class="meta">
          <span class="timestamp">- 








  



<time datetime="2016-12-25T23:15:50+09:00" pubdate data-updated="true"></time> -</span>
          
        </p>
      </div>
    
  </header>


  <div class="entry-content"><p>この記事は <a href="http://qiita.com/advent-calendar/2016/go3">Go (その3) Advent Calendar 2016</a> の24日目の記事です(代打)．
メリークリスマス!</p>

<p>本記事では Go 言語プロジェクトの CI で回すと便利な各種lintの紹介やカバレッジ計測の方法などなどについて紹介します．</p>

<h2>Go 言語おすすめ linter</h2>

<p>Go の lint 一覧といえば <a href="https://github.com/alecthomas/gometalinter">gometalinter</a> じゃん?
みたいな話もあると思うのですが，CIで回すには個別に linter を明示的に回すほうが良いかと思います．
ということで 僕が普段使ってるオススメ linter の紹介です．</p>

<h3>go vet</h3>

<ul>
<li><a href="https://golang.org/cmd/vet/">vet - The Go Programming Language</a></li>
<li>おすすめ度: ★★★★★</li>
</ul>


<blockquote><p>Vet examines Go source code and reports suspicious constructs, such as Printf
calls whose arguments do not align with the format string. Vet uses
heuristics that do not guarantee all reports are genuine problems, but it can
find errors not caught by the compilers.</p></blockquote>

<p>Go 言語標準でついているlintツールで，コンパイラが検出しないエラーを検出できます．
false positive な結果も無いようにデザインされているのでエラーがリポートされた場合は安心してCIをfailにできます．
go vet に検出されたエラーはほぼ100%直したほうがよいでしょう．</p>

<h3>golint</h3>

<ul>
<li><a href="https://github.com/golang/lint">golang/lint: This is a linter for Go source code.</a></li>
<li>おすすめ度: ★★★★☆</li>
</ul>


<blockquote><p>Golint differs from gofmt. Gofmt reformats Go source code, whereas golint prints out style mistakes.
Golint differs from govet. Govet is concerned with correctness, whereas golint is concerned with coding style.</p></blockquote>

<p>gofmtがコードのリフォーマットを，govetがコードの正確性をチェックするのに対して，golint
は Go のソースコードの <strong>&ldquo;コーディングスタイル&rdquo;</strong>
の問題を報告します．これはエラーというよりも &ldquo;suggestion&rdquo; に近く，
基本的に従っていたほうがGoの慣習に沿った確実によいコードになるのですが，
まれに，いやここの関数はコメント書かなくても絶対いいよね&hellip;とかいうケースもあり
若干消耗することもあるので星4です．</p>

<p>なお，結局はコーディングスタイルの問題をリポートするという思想からデフォルトでは問題があっても
exit code は 0 になるので，落としたい場合は <code>-set_exit_status</code> flag を付けましょう．</p>

<h3>errcheck</h3>

<ul>
<li><a href="https://github.com/kisielk/errcheck">kisielk/errcheck: errcheck checks that you checked errors.</a></li>
<li>おすすめ度: ★★★☆☆</li>
</ul>


<p>errcheck は関数のエラーの返り値をハンドリングチェックしているかどうかを静的に解析してくれるツールです．
エラーを捨てた状態の場合思わぬ動作(nilになってたりだとか)するので，これをチェックしてくれるのは大変嬉しいです．</p>

<p>ただし，少し実際直さなくてもいいという意味でのfalse positive が多くCIで動かすには工夫が必要で星3です．エラーをチェックしてくれるという便利度は満点．
なお，最近は標準ライブラリで必ずエラーがnilとして返ってくるような関数についてはリポートしないという
false positive を減らす工夫もされているようです．</p>

<h3>staticcheck</h3>

<ul>
<li><a href="https://github.com/dominikh/go-staticcheck">dominikh/go-staticcheck: Staticcheck is go vet on steroids, applying a ton of static analysis checks you might be used to from tools like ReSharper for C#</a></li>
<li>おすすめ度: ★★★★★</li>
</ul>


<p>staticcheck は一言で言うとサードパーティーの <code>go vet</code>です．go vet でチェックされていないようなことを静的に解析してくれます．
(例えば正規表現がvalidかチェックしてくれるかなどなど&hellip;たくさん項目があるのでREADMEを見てみてください．)</p>

<p>作者の <a href="https://github.com/dominikh">dominikh さん</a> は Go
言語の開発にも関わっていて，dominikh さん製Go lint ツールは個人的には
信頼できる印象です．github/go の issue でも  go vet のissueなどに， staticcheck
は実際こういうのチェックしてるけどと言った感じで参照されてたりするのを見かけます．</p>

<p>そして次の2つのツールも dominikh さん製です．</p>

<h3>gosimple</h3>

<ul>
<li><a href="https://github.com/dominikh/go-simple">dominikh/go-simple: Gosimple is a linter for Go source code that specialises on simplifying code</a></li>
<li>おすすめ度: ★★★★★</li>
</ul>


<p>gosimple は一言で言うとdominikh さん製のサードパーティー <code>gofmt -s</code> です．もっとコードをシンプルに出来るところを報告してくれます．
(ただし執筆時現在，自動で修正してくれるオプションとかはない)</p>

<p>例えば <code>if err != nil { return err }; return nil</code> といった構造のコードがあれば
<code>return err</code> で十分だよ? と報告してくれます．</p>

<p>報告に false positive もない印象で，あーそんなメソッドあったのか〜ということに気付いたりできてオススメです．</p>

<h3>go-unused</h3>

<ul>
<li><a href="https://github.com/dominikh/go-unused">dominikh/go-unused: Check Go programs for unused identifiers</a></li>
<li>おすすめ度: ★★★★★</li>
</ul>


<p>使ってない identifier をチェックしてくれます．
Go のコンパイラ自体が使ってない変数があるとコンパイル通らないという話もありますが，
unused は グローバル変数の var や const, struct の field，export されていない関数などで
使われていないものを報告してくれます．</p>

<p>報告してくれないのは使われてない関数の引数くらいでしょうか? これはインターフェースを満たすための関数など，
引数もらうけど使わないんやというケースなどを考えて報告されていないのではないかという気がします．[要出典]</p>

<p>また個人的には使えてないので強くオススメできませんが，パッケージのリストを渡して
exported なもので，渡したパッケージ内で使われていないものをチェック出来る機能もあります．
<a href="https://github.com/dominikh/go-unused#whole-program-analysis">https://github.com/dominikh/go-unused#whole-program-analysis</a>
&ldquo;internal&rdquo; packages などを使っていたりする場合は便利かもしれないですね．</p>

<p>unused は個人的には大変便利に使っていて，ごくまれにデバック用のexportしてない関数を報告されて，
あー&hellip;ってなる以外に false positive な結果もなく便利に使っています．</p>

<p>この前 interface を満たすためのダミーの関数をいろんな struct に定義してたんですが，
その際，追加すべきでない struct にも追加してしまい，それを unused が<a href="https://github.com/haya14busa/go-vimlparser/pull/23#pullrequestreview-11276693">報告</a>
してくれたことがありました．インターフェースを満たすかどうかといった観点での&#8221;used&#8221;もちゃんと見てくれていて大変良い子だな〜と思い感動しました．
オススメです．</p>

<h3>gofmt -s</h3>

<ul>
<li><a href="https://golang.org/cmd/gofmt/">gofmt - The Go Programming Language</a></li>
<li>おすすめ度: ★★★★☆</li>
</ul>


<p>linter ではない若干番外編その1．</p>

<p><code>gofmt -s</code> の結果 diff があるかどうか，つまりもっとシンプルにかけた部分がないかということをチェックできます．</p>

<p>コマンド: <code>(! gofmt -s -d . | grep '^')</code></p>

<p>括弧は travis などのyamlでvalidなものにするために使っています．
gofmt も exit code が 1 になったりすることはないので個人的には <code>grep '^'</code>
の結果を否定することによって，diffを表示しつつ，diffがあればfailにするという手法を使っています．
(<code>xargs -r</code> とかはMacでは<code>-r</code>がないとかがある&hellip;)</p>

<p>基本的にGo言語開発時はみんな gofmt かけていると思いますが，<code>-s</code> は付けていなかったり，
<code>goimport</code> で <code>gofmt</code> を代用していた場合に <code>-s</code> オプションがなくてかけてなかったりするので
CI で実行するとちょっと便利です．</p>

<p>ちょっと便利なんですが，<code>-s</code> つけるとめっちゃシンプルになって絶対いいよね&hellip;! というよりは，
あー手元で実行してなくて，CIサーバでdiffでちゃったよ&hellip;直すか&hellip;とちょ〜っとだけ消耗することが
あるという意味で個人的にはオススメ度星4です．(goimport <code>-s</code>フラグ足してくれ〜)</p>

<h3>go test -race</h3>

<ul>
<li>おすすめ度: ★★★★★</li>
</ul>


<p>linter ではない若干番外編その2．
<code>go test</code> に <code>-race</code> を付けるとrace condition があるかチェックしてくれます．
特に goroutine とか使ってるコードであれば，CIでのテスト実行時にはぜひ付けておくべきでしょう．
僕も何度も<code>-race</code>に怒られてコード直したり，ああここlockいるなと気付かされております．</p>

<h3>その他</h3>

<p>あんまり僕がまだ使えてなくて，ちゃんとオススメできないけど便利な静的チェックツールはいくつかあります．</p>

<h4>interfacer</h4>

<ul>
<li><a href="https://github.com/mvdan/interfacer">https://github.com/mvdan/interfacer</a></li>
<li>引数の型とかインターフェースでいいじゃん?というところを指摘してくれる. e.g. <code>*os.File</code> -> <code>io.Reader</code></li>
<li>個人的にはインターフェースにするといいところは最初からインターフェース使ってたりするしそこまでの恩恵は感じない</li>
</ul>


<h4>gosum</h4>

<ul>
<li><a href="https://github.com/haya14busa/gosum">https://github.com/haya14busa/gosum</a></li>
<li>急に拙作ツールの宣伝(?)</li>
<li>Go のインターフェースで直和型っぽいことを表現したときの，type switch に抜け漏れがないかを静的にチェックするツールです．</li>
<li>Scala でいう sealed trait のパターンマッチでコンパイラが抜け漏れがあると warning だしてくれるというやつのGoバージョン</li>
<li>詳しくはこの記事に書きました ->  <a href="https://medium.com/@haya14busa/sum-union-variant-type-in-go-and-static-check-tool-of-switch-case-handling-3bfc61618b1e#.lh90e9kx1">Sum/Union/Variant Type in Go and Static Check Tool of switch-case handling – Medium</a></li>
<li>書いてみて，使ってみて実際便利だと思ってるんですが，まだちゃんとCIで回したりはしてないので，その他枠で雑に紹介です．</li>
</ul>


<p>ところで linter 書くときって，AST ベースで解析するツールが僕の観測範囲では多いと思うですが，
Goは必要であれば <a href="https://golang.org/pkg/go/types/">go/types</a> パッケージを使って型情報まで使って
解析できるので大変便利ですね&hellip;! 標準ライブラリでカバーされてるところも +1</p>

<p><strong>&ldquo;go/ast ではしゃいでるのはもう古い! 時代は go/types !&rdquo;</strong> みたいな煽りタイトルの解説記事を最近は待ち望んでます．
go/types 関連は標準ライブラリの中でもかなり大きいものなのでなかなか僕もまだ全貌を理解できてないです．</p>

<h4>その他のその他</h4>

<p><a href="https://github.com/alecthomas/gometalinter">gometalinter</a> とか <a href="https://goreportcard.com/report/github.com/haya14busa/reviewdog">Go Report Card</a> で紹介されているツール．</p>

<p><a href="https://github.com/fzipp/gocyclo">https://github.com/fzipp/gocyclo</a>
とかイマイチ恩恵を受けたことがないんですが，gometalinter とか <a href="https://goreportcard.com/report/github.com/haya14busa/reviewdog">Go Report Card</a>
で使われているツールは参考になるかもしれません．</p>

<h2>reviewdog: linter の false positive と闘う</h2>

<p>特に golint や errcheck など，上記でオススメしたlinterの中には，false positive
なリポートが結構あって，めっちゃ便利でチェックしたいんだけど CI で fail
にしづらい&hellip; というものがいくつかあります．</p>

<p>そこで拙作ツール <a href="https://github.com/haya14busa/reviewdog">reviewdog</a> の紹介です．(宣伝)</p>

<p>もちろん Go 製です!</p>

<p><a href="https://github.com/haya14busa/reviewdog/pull/63#pullrequestreview-13287340"><img src="../images/post/2016-12-26-reviewdog.png" alt="" /></a></p>

<p>(画像は実際のPull Requestのコメントへのリンクになってます)</p>

<p>reviewdog は Go 言語の linter に限らず，任意のコマンドの結果を&#8217;errorformat&#8217;
という形式を使うことでパースして，<em>diff</em> で新たに追加された部分にたいする問題だけを
表示したり，GitHub にコメントすることが出来るツールです． 詳しくは -> <a href="http://haya14busa.com/reviewdog/">reviewdog を飼ってコードレビューや開発を改善しませんか - haya14busa</a></p>

<p>結果をdiffでフィルターすれば，それらの問題についてのみPull
Requestのレビュー時やコミット時にチェックすることが出来るので，
もし false positive な結果な場合は単に無視すれば次回以降に同じ問題は報告されません．</p>

<p>もちろん，例えば先に紹介した unused などは全然diffと関係ない部分で新たに問題がおきたりすることもあり，
結果を diff でフィルターするというのはfalse positiveと闘う銀の弾丸ではないのですが，
多くの場合これで十分機能を果たすでしょう．
(一応 diff 外の問題もうまくまとめて報告する仕組みも足したいな〜という気持ちはあります)</p>

<p>Go 製ツールである reviewdog は自分自身のコードでドックフーディングしていて，この記事で紹介した
いろんなGo 用 linter を実行していて，上記の画像のように実際に便利に使っています．
参考: <a href="https://github.com/haya14busa/reviewdog/blob/08050fc886b39f7caa4b0f39bcb2188043030214/reviewdog.yml">reviewdog/reviewdog.yml</a>
(最近はyamlでも管理できるようにしていて，より簡単にローカルで実行したり，git hook で実行しやすくしたりしたいなどと改善しています)</p>

<h2>Goのテストカバレッジをレビューでも活用する</h2>

<p>Go は標準で <code>go test -coverprofile=coverage.out .</code> などと実行するとテストカバレッジを取得することができます．
ただ実は CI などでカバレッジを取得する際は注意点があり，複数のパッケージをまとめてカバレッジを計測することはできません．
つまり例えば <code>go test -coverprofile=coverage.out ./...</code> とはできません．これは
<code>go test</code> 内部ではパッケージごとにテスト実行用バイナリを作成してそれぞれ実行してるという設計になっていることに起因します．
<a href="https://github.com/golang/go/issues/6909#issuecomment-233493644">issue</a> は上がってますが標準では対応するのはなかなか骨が折れそうです．
(ちょっと修正してコントリビューションしてみようかと格闘しましたが構造的に地味に大変そうでした&hellip;)</p>

<p>そこで現状で，複数パッケージのテストカバレッジに対応するために色んな所で Makefile やGoのツールを使うといった解決方法が紹介されています．
しかし!紹介されていて，確かにある程度はどれも動くのですが，実は多くのスクリプトはちょっと片手落ちなものになっています．
例えば go test の <code>-coverpkg</code> 引数を使わないと依存先のコードカバレッジが取得できてなかったり，
結果の coverage.out に重複行が生まれるケースがあったりします．</p>

<h3>解決策</h3>

<p>mattn さんの <a href="https://github.com/mattn/goveralls">mattn/goveralls</a>
では上記の問題に対応したマルチパッケージ対応テストカバレッジ機能が備わっています．というか僕がPull Request しました．
<a href="https://coveralls.io/">Coveralls</a> に投稿する場合は goveralls を使うと良いと思います.  (<code>goveralls -service=travis-ci</code> でよしなにやってくれる)</p>

<h3>ローカルでは?</h3>

<p>goveralls にコントリビューションしたあと，あれ&hellip;これローカルでもやりたいじゃん&hellip;ということに気付き，
既存のMakefileソリューションや似たツールはいくつかあるにはあったんですが，上記の問題などの対応とか
いろいろ面倒だったのでマルチパッケージカバレッジ作成用go test のラッパーツールを作りました．</p>

<p><a href="https://github.com/haya14busa/goverage">haya14busa/goverage: go test -coverprofile for multiple packages</a></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ goverage -coverprofile=coverage.out ./...</span></code></pre></td></tr></table></div></figure>


<p>とかするといい感じに coverage.out が生成されます．便利．</p>

<h3>codecov に投稿してレビューでも活用する - &ldquo;おい、coverall もいいけど codecov 使えよ&rdquo;</h3>

<p>サブタイは <a href="https://twitter.com/b4b4r07">b4b4r07</a> さんリスペクトです． ref: <a href="http://qiita.com/b4b4r07/items/9e1bbffb1be70b6ce033">おい、peco もいいけど fzf 使えよ - Qiita</a></p>

<p><a href="https://codecov.io/">Codecov</a> という <a href="https://coveralls.io/">Coveralls</a> と似たサービスがあるのはご存知でしょうか?
僕は以前からたまに見かけたことはあったのですが，最近はじめて使ってみて，断然 coverall よりいいじゃん&hellip;!!! と感じました．</p>

<p>全体的に洗練されてる&hellip;というよさもあるんですが，一番いいところは Pull Request の diff に対するカバレッジを表示できて，
ブラウザの拡張をインストールすれば GitHub の Pull Request 画面上でカバーされた行をオーバーレイで確認できるところが大変気に入りました．</p>

<p><a href="https://github.com/haya14busa/reviewdog/pull/63#pullrequestreview-13287340"><img src="../images/post/2016-12-26-codecov-pull-request.png" alt="" /></a></p>

<p>もちろん Codecov 上のページでも見れます: <a href="https://codecov.io/gh/haya14busa/reviewdog/pull/63/compare">Compare ⋅ haya14busa/reviewdog</a></p>

<p>Go 言語リポジトリのカバレッジを travis で計測して codecov へ投稿する例:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># .travis.yml
</span><span class='line'>install:
</span><span class='line'>  - go get github.com/haya14busa/goverage
</span><span class='line'>
</span><span class='line'>script:
</span><span class='line'>  - goverage -coverprofile=coverage.txt ./...
</span><span class='line'>
</span><span class='line'>after_success:
</span><span class='line'>  - goveralls -service=travis-ci -coverprofile=coverage.txt
</span><span class='line'>  - bash &lt;(curl -s https://codecov.io/bash)</span></code></pre></td></tr></table></div></figure>


<p><a href="https://github.com/codecov/example-go#caveat-multiple-files">codecov 公式のGo言語用リポジトリの例</a> では Makefile を使ってますが，
完全に上記のマルチパッケージサポートの問題を踏んでるので <code>goverage</code> を使うと良いと思います．</p>

<p>テストカバレッジは別に100%を目指さなくてもよいと思っていて，全体のカバレッジが何％以下とか何％下がったらステータスをfail
にするといった機能がcoverallやcodecov にはありますが，この辺を有効にすると結構消耗するかと思います．</p>

<p>ただ，カバレッジを参考にすることは有用だし，ユニットテストは基本的に書くべきです．
Pull Request などではカバーすべきところをしっかりカバーしたテストを期待したいし，，
レビュー時にもそのあたりが可視化されると大変便利です．</p>

<p>実際僕は Go のレビューするときに手元でテストまわしてcoverageみて，ここテストそもそも無いから足して欲しいだとか，
この行はカバーされてないけど，カバーすべき部分なのでテストケース足して欲しいとか言ったりするんですが，
codecov を使うとこのフローがやりやすいし，レビュイーもPull Request を出した時点で自分で気付いて
テスト足したりできると思います．</p>

<p>実は codecov 使い始めたのは最近で，僕自身がチーム開発として使った経験はまだないのですが，
coverall よりも codecov 使うとこの辺いい感じに可視化されて人間が指摘しなくてもよくなったり，
レビュワーとして指摘しやすくなったりすると思います．</p>

<p>せっかく Go という言語は標準でテストが書きやすく，カバレッジ計測もしやすいので，ぜひ皆さんもカバレッジを計測して，codecov 使ってみてはいかがでしょうか?</p>

<h3>まとめ</h3>

<p>Go のCIでまわすと便利なlintツールを紹介したり，テストカバレッジの取得方や codecov のオススメなどをしました．
Go は <code>go/ast</code>, <code>go/types</code> など <code>go/</code> 下の標準パッケージを使ってコードをパースしてASTを取得したり，型情報を取得したりなど
するライブラリが用意されているので，必要に応じて自前でチェックツールを作ったりもしやすく面白いです．</p>

<p>この記事で紹介したものは，一般的に多く使われているみなさんが知っているようなものから，あまり知られてないものまであるかと思いますが，
すべて少なくとも僕が使っていて便利だなぁ〜，と思ったものを紹介してみました．
他に便利なオススメツールなどがあれば教えてください！</p>

<p>個人OSSプロジェクトではレビュワー最初はいない問題などがあり，最近はPull Requestを開いてlint チェックさせたり，カバレッジみたり，
改めてブラウザ画面上でセルフレビューするなどしていて，まぁちょっと面倒もあるけど良い感じです．
あとは設計レビューとかもしてくれるGoのツールがあればカンペキですね〜〜〜！！！１</p>

<p>もちろんチーム開発でのレビューでも，消耗しがちな非人間的な指摘は機械にやってもらって，
もっと大事な観点をレビューするために，この記事で各種紹介した手法は役に立つかなと思います．</p>

<p>来年も Go 書いていくぞ!</p>
</div>
  
  


      <footer>
      
      - <a href="/ci-for-go-in-end-of-2016/">Go の CI で lint と カバレッジ回して非人間的なレビューは自動化しよう in 2016年</a>
      <time datetime="2016-12-25T23:15:50+09:00" pubdate><span class='month'>Dec</span> <span class='day'>25</span> <span class='year'>2016</span></time>
      
      <span class="categories">posted in <a class='category' href='/categories/go/'>go</a></span>
      
      </footer>
    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/vim-go-client/">Go で Vim プラグインを書く</a></h1>
    
    
      <div class="post-meta">
        <p class="meta">
          <span class="timestamp">- 








  



<time datetime="2016-12-21T18:14:54+09:00" pubdate data-updated="true"></time> -</span>
          
        </p>
      </div>
    
  </header>


  <div class="entry-content"><p>この記事は <a href="http://qiita.com/advent-calendar/2016/vim">Vim アドベントカレンダー 2016</a> の21日目の記事です．</p>

<p>最近は Go 言語が大好きすぎて，Vim plugin も Go で書きたい!!! という欲が出てきたので，
Vim plugin を Go で書く方法について紹介します．</p>

<h2>Go で Vim plugin を書くとは?</h2>

<p>一口に Go で Vim plugin を書くといっても</p>

<ol>
<li>Go で書いたバイナリがメインで Vim script の autoload 関数などから呼ぶ．例: <a href="https://github.com/mattn/vim-filewatcher">https://github.com/mattn/vim-filewatcher</a></li>
<li>Go 側からも Vim script を呼ぶ，つまり Vim script で Vim の情報を取得するところなど含めて，ほぼ全部 Go で書く．</li>
</ol>


<p>という 2 段階があると思います．本記事では2の方法も含めて紹介しますがまずは1から行きましょう．</p>

<h2>1. Go で書いたバイナリをつかった Vim plugin の作り方</h2>

<p>これは先程例にあげた <a href="https://github.com/mattn/vim-filewatcher">https://github.com/mattn/vim-filewatcher</a> がシンプルでわかりやすいです．</p>

<p><a href="https://github.com/mattn/vim-filewatcher/blob/22594895e16cb4de11afa37f04d88a996f48da58/filewatcher/filewatcher.go">filewatcher/filewatcher.go</a>
で書いた Go をインストール時に <code>cd filewatcher &amp;&amp; go get -d &amp;&amp; go build</code> でビルドし，
<a href="https://github.com/mattn/vim-filewatcher/blob/22594895e16cb4de11afa37f04d88a996f48da58/autoload/filewatcher.vim">autoload/filewatcher.vim</a>
でこのバイナリを <code>job</code> をつかって呼んでいます．</p>

<p><code>go get -d</code> を呼ぶことで依存するパッケージをダウンロードし，<code>go build</code> することで <code>$GOBIN</code> などを汚さずにプラグインディレクトリにバイナリを配置できます．</p>

<h4><a href="https://github.com/mattn/vim-filewatcher/blob/22594895e16cb4de11afa37f04d88a996f48da58/autoload/filewatcher.vim">autoload/filewatcher.vim</a></h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let s:cmd = expand('&lt;sfile&gt;:h:h:gs!\\!/!') . '/filewatcher/filewatcher' . (has('win32') ? '.exe' : '')
</span><span class='line'>if !filereadable(s:cmd)
</span><span class='line'>  finish
</span><span class='line'>endif
</span><span class='line'>
</span><span class='line'>function! filewatcher#watch(dir, cb)
</span><span class='line'>  return {'dir': a:dir, 'job': job_start([s:cmd, a:dir], { 'out_cb': a:cb, 'out_mode': 'nl' })}
</span><span class='line'>endfunction</span></code></pre></td></tr></table></div></figure>


<p>バイナリを呼んでいるVim script もとてもシンプルで， windows かどうか見ながらバイナリのパスを取得し，
それを <code>job</code> で呼ぶだけです．簡単．プラグインの性質によっては <code>job</code> ではなく <code>system()</code> などを使ってもよいでしょう．</p>

<p>また，開発時には <code>g:plugin_name#debug</code> などを作ってそれを見て <code>go run</code> を呼ぶというふうに変えることもできます．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function! s:separator() abort
</span><span class='line'>  return fnamemodify('.', ':p')[-1 :]
</span><span class='line'>endfunction
</span><span class='line'>
</span><span class='line'>let s:is_windows = has('win16') || has('win32') || has('win64') || has('win95')
</span><span class='line'>
</span><span class='line'>let s:base = expand('&lt;sfile&gt;:p:h:h')
</span><span class='line'>let s:basecmd = s:base . s:separator() . fnamemodify(s:base, ':t')
</span><span class='line'>let s:cmd = s:basecmd . (s:is_windows ? '.exe' : '')
</span><span class='line'>
</span><span class='line'>if g:plugin_name#debug
</span><span class='line'>  let s:cmd = ['go', 'run', s:basecmd . '.go']
</span><span class='line'>elseif !filereadable(s:cmd)
</span><span class='line'>  call system(printf('cd %s && go get -d && go build', s:base))
</span><span class='line'>endif</span></code></pre></td></tr></table></div></figure>


<p>僕が作ったプラグインから引っ張ってきた例で autoload/filewatcher.vim ほどシンプルではないですが，もうちょっとなんとか出来るかもしれないですね．
main パッケージのファイル (<code>s:basecmd . '.go'</code>) を1ファイルにすると<code>go run</code>で呼びやすいです．</p>

<h2>2. Go 側からも Vim script を呼ぶ必要があるようなプラグインの作り方</h2>

<p>mattn/filewatcher ではファイルの変更を検知してstdout にJSONを吐いて，それが job の callback に渡されるという形式で単体で簡潔してましたが，
場合によっては Go 側から Vim の状態を取得したり，Vim script を呼んだりしたい場合もあります．
そういうプラグインを作るには，job を JSON モードで起動し， <a href="http://vim-jp.org/vimdoc-ja/channel.html#channel-commands">:h channel-commands</a>
を使うことによって実現できます．</p>

<h4><a href="http://vim-jp.org/vimdoc-ja/channel.html#channel-commands">:h channel-commands</a></h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>JSON チャンネルを使用すると、サーバープロセス側はVimへコマンドを送信できます。
</span><span class='line'>そのコマンドはチャンネルのハンドラーを介さずに、Vimの内部で実行されます。
</span><span class='line'>
</span><span class='line'>実行可能なコマンドは以下のとおりです:           *E903* *E904* *E905*
</span><span class='line'>    ["redraw", {forced}]
</span><span class='line'>    ["ex",     {Ex コマンド}]
</span><span class='line'>    ["normal", {ノーマルモードコマンド}]
</span><span class='line'>    ["eval",   {式}, {数値}]
</span><span class='line'>    ["expr",   {式}]
</span><span class='line'>    ["call",   {func name}, {argument list}, {number}]
</span><span class='line'>    ["call",   {func name}, {argument list}]</span></code></pre></td></tr></table></div></figure>


<p><code>{数値}</code>(<code>{number}</code>) は id で，job -> Vim に渡すさいはマイナスを指定する必要があり，
その渡した id と共に評価された値が返ってきます．</p>

<p>例えば Go 側で stdout に <code>["expr","line('$')", -2]</code> を書き込むと， Vim
が<code>line('$')</code> を評価してその結果が stdin に <code>[-2, "last line"]</code>
といった結果が返ってきます．</p>

<p>便利すぎる&hellip;</p>

<p>ということでidの取扱などこのあたりの処理を毎回丁寧にやるのは面倒くさいので，
<a href="https://github.com/haya14busa/vim-go-client">https://github.com/haya14busa/vim-go-client</a> というラッパーを作りました．
ドキュメント: <a href="https://godoc.org/github.com/haya14busa/vim-go-client#Client">https://godoc.org/github.com/haya14busa/vim-go-client#Client</a></p>

<p><a href="https://godoc.org/github.com/haya14busa/vim-go-client#Client"><code>type Client</code></a> が上記の channel-commands などのに相当するメソッドを持っており，
<a href="https://godoc.org/github.com/haya14busa/vim-go-client#Handler"><code>type Handler</code></a> がメッセージの受け渡しを担当します．</p>

<p>サンプル: <a href="https://github.com/haya14busa/vim-go-client/blob/32a96bf256fabc81dff549a70328a6bb3f24e9b5/_example/dev/job/job.go"><code>_example/dev/job/job.go</code></a></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>package main
</span><span class='line'>
</span><span class='line'>import (
</span><span class='line'>  "fmt"
</span><span class='line'>  "log"
</span><span class='line'>  "os"
</span><span class='line'>  "time"
</span><span class='line'>
</span><span class='line'>  vim "github.com/haya14busa/vim-go-client"
</span><span class='line'>)
</span><span class='line'>
</span><span class='line'>type myHandler struct{}
</span><span class='line'>
</span><span class='line'>func (h *myHandler) Serve(cli *vim.Client, msg *vim.Message) {
</span><span class='line'>  log.Printf("receive: %#v", msg)
</span><span class='line'>  if msg.MsgID &gt; 0 {
</span><span class='line'>
</span><span class='line'>      if msg.Body == "hi" {
</span><span class='line'>          cli.Send(&vim.Message{
</span><span class='line'>              MsgID: msg.MsgID,
</span><span class='line'>              Body:  "hi how are you?",
</span><span class='line'>          })
</span><span class='line'>      } else {
</span><span class='line'>          start := time.Now()
</span><span class='line'>          log.Println(cli.Expr("eval(join(range(10), '+'))"))
</span><span class='line'>          log.Printf("cli.Expr: finished in %v", time.Now().Sub(start))
</span><span class='line'>      }
</span><span class='line'>
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>func main() {
</span><span class='line'>  handler := &myHandler{}
</span><span class='line'>  cli := vim.NewClient(vim.NewReadWriter(os.Stdin, os.Stdout), handler)
</span><span class='line'>  done := make(chan error, 1)
</span><span class='line'>  go func() {
</span><span class='line'>      done &lt;- cli.Start()
</span><span class='line'>  }()
</span><span class='line'>
</span><span class='line'>  cli.Ex("echom 'hi'")
</span><span class='line'>  log.Println(cli.Expr("1+1"))
</span><span class='line'>
</span><span class='line'>  select {
</span><span class='line'>  case err := &lt;-done:
</span><span class='line'>      fmt.Printf("exit with error: %v\n", err)
</span><span class='line'>      fmt.Println("bye;)")
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>handler := &amp;myHandler{}</code> でハンドラを作って <code>cli := vim.NewClient(vim.NewReadWriter(os.Stdin, os.Stdout), handler)</code>
で stdin/stdout を介してVim と通信できるclientを作成しています．
あとはこいつを <code>cli.Start()</code> しておけば Vim から <code>ch_sendexpr()</code> などが呼ばれると handler に中身が渡されるし，
<code>cli.Ex("echom 'hi'")</code> などを呼ぶと Vim 側で <code>echom 'hi'</code> が実行されます．</p>

<h2>実例: vim-stacktrace</h2>

<p>実際に vim-go-client を使ってひとつプラグインを書いてみました．</p>

<p><a href="https://github.com/haya14busa/vim-stacktrace">haya14busa/vim-stacktrace</a></p>

<p><img src="https://raw.githubusercontent.com/haya14busa/i/e7ef65e590e850ea37425c6ebf4479c1422ef8c8/vim-stacktrace/stacktracefromhist.gif" alt="stacktracefromhist.gif (1287×800)" /></p>

<p>Vim のスタックトレースをquickfix に流し込むプラグインでやっていることとしては6日目の記事の <a href="http://qiita.com/tmsanrinsha/items/0787352360997c387e84">Vim scriptのエラーメッセージをパースしてquickfixに表示する - Qiita</a>
と近いです．</p>

<p>autoload 関数からjobに <code>ch_evalexpr</code>
する部分([link]<a href="https://github.com/haya14busa/vim-stacktrace/blob/933f9d10c7ef99467c27609fcdd80be37c0712e8/autoload/stacktrace.vim#L12-L30">https://github.com/haya14busa/vim-stacktrace/blob/933f9d10c7ef99467c27609fcdd80be37c0712e8/autoload/stacktrace.vim#L12-L30</a>())
を除いてほぼ全てがGoで実装されていて，現時点で Go の割合が 87.8 % です．</p>

<p><img src="https://cloud.githubusercontent.com/assets/3797062/21386073/5e56a5aa-c7b4-11e6-9cac-869cbb8ffe8d.png" alt="image" /></p>

<p>実装の中身としても，Vim のスタックトレースからは関数内における行番号しかとれず，ファイルの行番号が取得できない問題があるのですが，
それをGoで実装したVim script parser (<a href="https://github.com/haya14busa/go-vimlparser">https://github.com/haya14busa/go-vimlparser</a>) を使ってファイルをパースし，行番号を取得することができています．
また，<code>:CStacktraceFromhist</code> などは Vim script の <code>inputlist</code> をGo側から呼んでいてインテラクティブにVimと協調して動作できることも示せました．</p>

<h2>Go で書くよさ</h2>

<p>実際に Vim script でやっているひともいたように，vim-stacktrace は Go
が無いとかけなかったといった類のものではないですが，Goで書くといいことがたくさんありました．</p>

<ul>
<li>型がある安心感</li>
<li>テストが標準に備わっていて書きやすい (go test)</li>
<li>カバレッジも取れる! (go test -coverprofile)</li>
<li>Go のパッケージが使える (go-vimlparser, etc&hellip;)</li>
<li>etc&hellip;</li>
</ul>


<p>カバレッジなどは現在Vim scriptのテスティングフレームワークではサポートされていないし，なかなか実装しようとしてもムズカシそうなのですが，
Goでかけば標準でついてきます．とても便利．</p>

<p>coverall も使えます: <a href="https://coveralls.io/github/haya14busa/vim-stacktrace?branch=master"><img src="https://coveralls.io/repos/github/haya14busa/vim-stacktrace/badge.svg?branch=master" alt="Coverage Status" /></a></p>

<p>逆にPure Vim script と比較して悪いところや注意点があるとすれば</p>

<ul>
<li>vim-go-client がまだ安定してない</li>
<li>channel-commands がエラーをちゃんと返してくれない(エラーがあれば &ldquo;ERROR&rdquo; とだけ返ってくる)</li>
<li>チャンネルの通信で少しだけオーバーヘッドがある</li>
<li>現状vim/neovimに両対応できない</li>
</ul>


<p>といった感じでしょうか．もうちょっとvim-go-client精錬させたいですね&hellip;頑張ります&hellip;</p>

<h2>NeoVim のリモートプラグイン</h2>

<p>neovim 向けには実は <a href="https://github.com/neovim/go-client">neovim/go-client</a> というものが存在し，リモートプラグインをGoで書くことが出来るようです．</p>

<p><a href="http://vimconf.vim-jp.org/2016/">Vimconf 2016</a> で <a href="https://github.com/zchee">zchee</a> さんが発表していた nvim-go はこれが使われています．</p>

<p>スライド該当部分: <a href="http://go-talks.appspot.com/github.com/zchee/talks/vimconf2016.slide#33">http://go-talks.appspot.com/github.com/zchee/talks/vimconf2016.slide#33</a></p>

<p>正直なところ neovim のリモートプラグインの先行アドバンテージ(?)は大きく，vim-go-client と比較してかなり高機能になってます．
理想としては Vim 8 でも neovim でも使えるものをかけるようにしたいのですが， neovimのリモートプラグインが高機能であることや，
msgpack 依存であることからなかなか両方に対応することはムズカシイです&hellip;</p>

<p>うまく抽象化してロジックの部分だけ共通化して，vim8用/neovim用にメッセージのハンドラを管理してうんたん&hellip;みたいなことは出来るかも知れないので，
今後の研究課題という感じですね．あと僕がほとんどneovim使わないので nvim-go の仕様感とか知っている方はお話してくれると嬉しいです．
(Vimconf で zchee さんとその話ができたのは便利だった&hellip;)</p>

<h2>おわりに</h2>

<p>正直まだまだGoで書かれたVim plugin は少なく発展途上ですが，実用的なプラグインを作成することもできたので，可能性を感じます．
Go でかけばマルチプラットフォームに対応できるし，ライブラリがどうとか環境がどうとか気にすることなく動かせるので，Vim との親和性はかなり高いと思っています．</p>

<p>何よりGoはかわいい!書いていて楽しい!</p>

<p>まだまだ発展途上ですが，ぜひ皆さんもGoでVim プラグインを作ってみてください．</p>
</div>
  
  


      <footer>
      
      - <a href="/vim-go-client/">Go で Vim プラグインを書く</a>
      <time datetime="2016-12-21T18:14:54+09:00" pubdate><span class='month'>Dec</span> <span class='day'>21</span> <span class='year'>2016</span></time>
      
      <span class="categories">posted in <a class='category' href='/categories/go/'>go</a>, <a class='category' href='/categories/vim/'>vim,</a></span>
      
      </footer>
    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/golang-how-to-write-mock-of-interface-for-testing/">Golangにおけるinterfaceをつかったテストで Mock を書く技法</a></h1>
    
    
      <div class="post-meta">
        <p class="meta">
          <span class="timestamp">- 








  



<time datetime="2016-11-02T07:19:14+09:00" pubdate data-updated="true"></time> -</span>
          
        </p>
      </div>
    
  </header>


  <div class="entry-content"><p>いい記事に感化されて僕も何か書きたくなった。</p>

<p><a href="http://deeeet.com/writing/2016/10/25/go-interface-testing/">Golangにおけるinterfaceをつかったテスト技法 | SOTA</a></p>

<p>リスペクト:</p>

<ul>
<li><a href="http://mattn.kaoriya.net/software/lang/go/20161025113154.htm">Big Sky :: golang で終了を確認するテストの書き方</a></li>
<li><a href="http://deeeet.com/writing/2016/11/01/go-api-client/">GolangでAPI Clientを実装する | SOTA</a></li>
<li><a href="http://mattn.kaoriya.net/software/lang/go/20161101151118.htm">Big Sky :: GolangでAPI Clientを実装する、の続き</a></li>
</ul>


<p>今週のやつではなく先週のです．今週のは特に知見がなかった&hellip;<a href="https://github.com/grpc/grpc-go">grpc-go</a>とか使えたらクライアント勝手に生成されるしいいよねgrpc流行ると便利そう(感想) くらい</p>

<p><a href="http://deeeet.com/writing/2016/10/25/go-interface-testing/">Golangにおけるinterfaceをつかったテスト技法 | SOTA</a>
めっちゃいいなーと思ったんですが，テスト用 の mock を気軽に作るテクニックはあまり詳しく紹介されてなかったのでそのあたりの１つのテクニックを書きたい．</p>

<h2>前提</h2>

<p>僕もテストフレームワークや外部ツールは全く使わない．標準のtestingパッケージのみを使う．
<a href="https://github.com/stretchr/testify">testify</a> もいらないし， mock するために <a href="https://github.com/golang/mock">gomock</a> も基本はいらない．</p>

<p>とにかくGolangだけで書くのが気持ちがいい，に尽きる．</p>

<h2>テスト用 fake client をつくる</h2>

<p>全体の動くはずのgist: <a href="https://gist.github.com/haya14busa/27a12284ad74477a6fd6ed66d0d153ee">https://gist.github.com/haya14busa/27a12284ad74477a6fd6ed66d0d153ee</a></p>

<p>例えばこういう実装のテストを書くときのことを考えます．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>package main
</span><span class='line'>
</span><span class='line'>import (
</span><span class='line'>  "context"
</span><span class='line'>  "fmt"
</span><span class='line'>)
</span><span class='line'>
</span><span class='line'>type GitHub interface {
</span><span class='line'>  CreateRelease(ctx context.Context, opt *Option) (string, error)
</span><span class='line'>  GetRelease(ctx context.Context, tag string) (string, error)
</span><span class='line'>  DeleteRelease(ctx context.Context, releaseID int) error
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>type GhRelease struct {
</span><span class='line'>  c GitHub
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>func (ghr *GhRelease) CreateNewRelease(ctx context.Context) (*Release, error) {
</span><span class='line'>  tag, err := ghr.c.CreateRelease(ctx, nil)
</span><span class='line'>  if err != nil {
</span><span class='line'>      return nil, fmt.Errorf("failed to create release: %v", err)
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  // check created release
</span><span class='line'>  if _, err := ghr.c.GetRelease(ctx, tag); err != nil {
</span><span class='line'>      return nil, fmt.Errorf("failed to get created release: %v", err)
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  // ...
</span><span class='line'>  return &Release{}, nil
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>type Option struct{}
</span><span class='line'>type Release struct{}</span></code></pre></td></tr></table></div></figure>


<p>GitHub interface をテストでは mock したものを使いたい．そういうときには以下のように mock を作ると便利です．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>type fakeGitHub struct {
</span><span class='line'>  // インターフェース埋め込み
</span><span class='line'>  GitHub
</span><span class='line'>  FakeCreateRelease func(ctx context.Context, opt *Option) (string, error)
</span><span class='line'>  FakeGetRelease    func(ctx context.Context, tag string) (string, error)
</span><span class='line'>  // 埋め込みを使うので，例えば DeleteRelease はまだテストしないので mock
</span><span class='line'>  // しない... いうことができる．
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>func (c *fakeGitHub) CreateRelease(ctx context.Context, opt *Option) (string, error) {
</span><span class='line'>  return c.FakeCreateRelease(ctx, opt)
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>func (c *fakeGitHub) GetRelease(ctx context.Context, tag string) (string, error) {
</span><span class='line'>  return c.FakeGetRelease(ctx, tag)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><code>fakeGitHub</code> という struct を作成し，インターフェースをとにかく満たすために <code>GitHub</code>
interface を埋め込みます．</p>

<p>そして mock したいメソッドは新たに <code>func (c *fakeGitHub) CreateRelease(...) (...)</code> と
定義しなおし，実装の中身は <code>fakeGitHub</code> に持たせた <code>FakeCreateRelease</code> field に丸投げします．</p>

<p>このようにしてテスト用 mock を作るとそれぞれのテストで簡単に中身の実装を変えられるので大変便利です．</p>

<p>実際にテストしてみる例</p>

<h4>main_test.go</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>package main
</span><span class='line'>
</span><span class='line'>import (
</span><span class='line'>  "context"
</span><span class='line'>  "fmt"
</span><span class='line'>  "testing"
</span><span class='line'>)
</span><span class='line'>
</span><span class='line'>type fakeGitHub struct {
</span><span class='line'>  // インターフェース埋め込み
</span><span class='line'>  GitHub
</span><span class='line'>  FakeCreateRelease func(ctx context.Context, opt *Option) (string, error)
</span><span class='line'>  FakeGetRelease    func(ctx context.Context, tag string) (string, error)
</span><span class='line'>  // 埋め込みを使うので，例えば DeleteRelease はまだテストしないので mock
</span><span class='line'>  // しない... いうことができる．
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>func (c *fakeGitHub) CreateRelease(ctx context.Context, opt *Option) (string, error) {
</span><span class='line'>  return c.FakeCreateRelease(ctx, opt)
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>func (c *fakeGitHub) GetRelease(ctx context.Context, tag string) (string, error) {
</span><span class='line'>  return c.FakeGetRelease(ctx, tag)
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>func TestGhRelease_CreateNewRelease(t *testing.T) {
</span><span class='line'>  fakeclient := &fakeGitHub{
</span><span class='line'>      FakeCreateRelease: func(ctx context.Context, opt *Option) (string, error) {
</span><span class='line'>          return "v1.0", nil
</span><span class='line'>      },
</span><span class='line'>      FakeGetRelease: func(ctx context.Context, tag string) (string, error) {
</span><span class='line'>          return "", fmt.Errorf("failed to get %v release!", tag)
</span><span class='line'>      },
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  ghr := &GhRelease{c: fakeclient}
</span><span class='line'>
</span><span class='line'>  release, err := ghr.CreateNewRelease(context.Background())
</span><span class='line'>  if err != nil {
</span><span class='line'>      t.Error(err)
</span><span class='line'>      // =&gt; failed to get created release: failed to get v1.0 release!
</span><span class='line'>  }
</span><span class='line'>  _ = release
</span><span class='line'>  // ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>以下のような感じで，簡単にテスト用mockの実装を書いて，テストすることができます．</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fakeclient := &fakeGitHub{
</span><span class='line'>  FakeCreateRelease: func(ctx context.Context, opt *Option) (string, error) {
</span><span class='line'>      return "v1.0", nil
</span><span class='line'>  },
</span><span class='line'>  FakeGetRelease: func(ctx context.Context, tag string) (string, error) {
</span><span class='line'>      return "", fmt.Errorf("failed to get %v release!", tag)
</span><span class='line'>  },
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上記の例では1種類の実装しかテストしてないのであまり恩恵がわかりづらいかも知れないですが，
例えば error が帰ってきたときに正しくエラーハンドリングできてるかとか，
返り値をいろいろ変えたものをいくつか作ってテストする&hellip;といったことが上記のパターンを
使うことによって簡単にできます．Table Testing することも可能．</p>

<p>普通にわざわざstructごと作っていると，例えばテストの関数ないでは struct の method (e.g. <code>func (c *client) Func()</code>)
を定義することができません．</p>

<p>そこで <code>FakeFunc func()</code> というfield を持たせて実装を丸投げすることによって，
簡単にいろんな実装のテスト用 mock を作成してテストができるということの紹介でした．</p>

<h2>まとめ</h2>

<p>僕は最初にこのパターンを教わってなるほどなぁ&hellip;と思ったんですが，いざ世にでてみると(?)
ぜんぜんこのパターンを紹介しているものが見つからなかったので紹介してみました．
(一応どっかの medium の英語記事にこれに似たパターンが紹介されてたのを見た気もする&hellip;)</p>

<p>ぜひ使ってみてください．</p>

<h2>あまり関係ない追記</h2>

<p>この記事の主旨とは関係ないけど，基本的にテスト用ライブラリは使わないとはいえ，
たまににヘルパー関数ほしいなーというケースがあります．</p>

<p>でかい struct をテストで比較するときに，比較自体は <code>reflect.DeepEqual</code> で出来るのだけど，
もし違っていたときにどこが違うかを表示するのが面倒くさいのでヘルパー関数提供してくれるライブラリがほしい&hellip;</p>

<p>某社でgoのテスト書いてたときもこういう大きめのstruct比較するケースでは便利diff表示用ライブラリを
使っていた気がしたんだけど，なんかOSSで見つからない気がする&hellip; prettycmp みたいな名前だった気がするが
どうだったか&hellip; そもそも記憶違いな気もする&hellip;</p>

<p>追記: twitter で教えてもらいましたが <a href="https://github.com/kylelemons/godebug">https://github.com/kylelemons/godebug</a> っぽいです．
便利. <a href="https://godoc.org/github.com/kylelemons/godebug/pretty#Compare">https://godoc.org/github.com/kylelemons/godebug/pretty#Compare</a></p>
</div>
  
  


      <footer>
      
      - <a href="/golang-how-to-write-mock-of-interface-for-testing/">Golangにおけるinterfaceをつかったテストで mock を書く技法</a>
      <time datetime="2016-11-02T07:19:14+09:00" pubdate><span class='month'>Nov</span> <span class='day'>02</span> <span class='year'>2016</span></time>
      
      <span class="categories">posted in <a class='category' href='/categories/go/'>go</a></span>
      
      </footer>
    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/reviewdog/">Reviewdog を飼ってコードレビューや開発を改善しませんか</a></h1>
    
    
      <div class="post-meta">
        <p class="meta">
          <span class="timestamp">- 








  



<time datetime="2016-10-24T07:44:34+09:00" pubdate data-updated="true"></time> -</span>
          
        </p>
      </div>
    
  </header>


  <div class="entry-content"><p><img src="https://raw.githubusercontent.com/haya14busa/i/d598ed7dc49fefb0018e422e4c43e5ab8f207a6b/reviewdog/reviewdog.logo.png" alt="reviewdog logo" /></p>

<p><img src="https://raw.githubusercontent.com/haya14busa/i/dc0ccb1e110515ea407c146d99b749018db05c45/reviewdog/sample-comment.png" alt="" /></p>

<p>GitHub: <a href="https://github.com/haya14busa/reviewdog">haya14busa/reviewdog: A code review dog who keeps your codebase healthy</a></p>

<p>英語記事: <a href="https://medium.com/@haya14busa/reviewdog-a-code-review-dog-who-keeps-your-codebase-healthy-d957c471938b#.r3hb734et">reviewdog — A code review dog who keeps your codebase healthy – Medium</a></p>

<p>reviewdog というlinter などのチェックツールの結果を自動で GitHub の Pull Request にコメントしたり，
ローカルでも diff の結果から新たに導入されたエラーだけを表示するようにフィルタリングできるツールを作りました．</p>

<p><a href="https://medium.com/@haya14busa/reviewdog-a-code-review-dog-who-keeps-your-codebase-healthy-d957c471938b#.r3hb734et">英語記事</a> を Medium に書いたし，README も書いたので
日本語記事はまぁいらないかなぁと思ったけど，柄にもなく Vim 関連以外で普通に便利ツールを書いてしまって，これは日本語でも簡単に共有しようかなぁと思いこの記事を書いています．
(とはいえ機能の実現方法として Vim は関係はしてるんですけどね.)</p>

<p>特に和訳とかではなく，英語ではなかなか文章に落としづらかったことをだらだら書こうかと思います．英語は難しい&hellip;
(だらだらと日本語を書いてるので日本語ができてるとは言ってない)</p>

<h2>背景とかきっかけ</h2>

<p>compiler や lint といったコードをチェックするツールはものによっては直さなくてもいいものをレポートすることがありますよね．
例えば Scala の compiler はオプションを与えたらかなりいろんな警告を出してくれますが，
別に直さなくてもいいケースがあるものがあったり， Play framework
で使ってると ルーティングファイルやテンプレートファイルに対して，こちらが直せない警告を
バンバンだしてきたりします．(これはバージョンを上げると直るっぽい?)</p>

<p><a href="https://github.com/golang/lint">golint</a> は <code>-set_exit_status</code> を付けないと問題を見つけても exit status が 1 になりませんが，
これはもともとあくまで コーディングスタイル の問題を見つけるものだという思想からでしょう．</p>

<blockquote><p>Golint differs from govet. Govet is concerned with correctness, whereas golint is concerned with coding style.</p></blockquote>

<p>Go の OSS プロジェクトでは CI で golint の問題があればビルドをFAILにすることが結構多いと思いますが，
本来直さなくてもいいところまで直さなくてはいけなくて消耗したりしていませんか?</p>

<p>去年 Google のインターンで Go 書いてたときは，実際 golint のエラーでテストがfail するとかではなく，
bot が自動でコメントしてくれてあとは勝手に直せという感じで便利でした．</p>

<p>まぁ直さなくてもいい結果は少なくて大抵は直すのですが，直さなくてもいいものはゼロではないです．
コメントで bot に直さなくてもいいものを指摘されたら単に無視してcloseすればいいので無駄に消耗せずにすんで便利．</p>

<p>また CI で落とすために指摘してくれると便利なことは多いけど設定で off にしてしまうケースもあるかなーと思います．
例えば JavaScript で関数の引数に使ってないものがあったら警告してくれると便利なケースもあるかなぁーという反面，
コールバック用関数などでは渡ってくるのがわかってるからいいんだよ！というケースとか．</p>

<p>あとは既存のコードベースに新しく linter を導入しようとすると，既存のコードに対してエラー
出まくって導入するために直していくのが面倒だなぁ&hellip; 放置していると新しいコードに対しても
lint が走らないので消耗する&hellip;ということもあるかと思います．</p>

<p>上記の問題を解決する1つの方法としては，とりあえずPull Request の差分に関して lint をかけたり
して自動でbotがコメントしてくれる仕組みがあれば，100% 円満解決ではなくともかなりつらみが
解消されるかと思います．</p>

<p>世の中にはすでにそういうサービスは一応あって <a href="https://houndci.com/">Hound CI</a>
とか <a href="https://sideci.com/">SideCI</a> がそうなんですが，使える言語やツールは限られています．
たとえば Vim の linter を Vim プラグインのレポジトリに対して使えるようになることはないでしょう.</p>

<p>また，ローカルでも(差分に対して lint などを書けるという意味で)実行できないと Pull Request 出さないとチェックできないので不便です．</p>

<p>ということで作ったのが <a href="https://github.com/haya14busa/reviewdog">reviewdog</a> になります．</p>

<p>あんまり技術的に面白いことがあったというよりは，本来あるべきものなのになかったので作ったという感じ．
汎用的に lint の結果をパースする手段をどのツールも提供してるものがないのが問題で，
reviewdog は Vim の Quickfix 用の &lsquo;errorformat&rsquo; という機能を Go で port することによって実現しました．</p>

<p>GitHub: <a href="https://github.com/haya14busa/errorformat">haya14busa/errorformat: Vim&rsquo;s quickfix errorformat implementation in Go</a></p>

<p>&lsquo;errorformat&rsquo; 形式を採用したのは僕が単に Vimmer だから&hellip; というのももちろんあるんですが，
仕様の全体を理解するのは結構大変とはいえ，簡単なerrorformatを書くのは簡単だし，それでいて
難しい複数行のエラーメッセージをパースできる利点があります．</p>

<p>emacs では compilation モードが Vim の quickfix に対応するようで，errorformat に対応するものは
正規表現とサブマッチのインデックスっぽいのですが，簡単な複数行エラーには対応してそうですが，
Vim の &lsquo;errorformat&rsquo; のほうが汎用的っぽいなーと思いました(詳しく見れてません)</p>

<p>&lsquo;errorformat&rsquo;, 実装ポーティングして仕様を理解していくと，かなりよくできているなーという印象で
Vim は時代の先を走ってると思いました．</p>

<p>また reviewdog 以外でも <a href="https://github.com/alecthomas/gometalinter">https://github.com/alecthomas/gometalinter</a> のもっと汎用的なバージョンを言語を問わず
errorformat を使って作るとかも可能なんじゃないかな〜と思います．(gometalinter 個人的にあんまり好きくないし)</p>

<h2>インストールとか使い方書こうかと思ったけど疲れたのでREADMEとか英語のpost読んでください</h2>

<ul>
<li><a href="https://github.com/haya14busa/reviewdog">haya14busa/reviewdog: A code review dog who keeps your codebase healthy</a></li>
<li><a href="https://medium.com/@haya14busa/reviewdog-a-code-review-dog-who-keeps-your-codebase-healthy-d957c471938b#.r3hb734et">reviewdog — A code review dog who keeps your codebase healthy – Medium</a></li>
</ul>


<p>あと雑だけど Google Doc の design doc な何かも一応ある <a href="https://docs.google.com/document/d/1mGOX19SSqRowWGbXieBfGPtLnM0BdTkIc9JelTiu6wA/edit#">reviewdog - Google Docs</a></p>

<h2>CI サービス連携問題</h2>

<p>reviewdog は Pull Request hook と実行環境さえあれば対応できてオープンなCIサービスの場合はGitHubへコメントするための
API トークンを安全に環境変数などで保存する方法があれば対応できます．</p>

<p>travis や circle ci といったメジャーなCIサービスは両方対応していて，最初は全然このあたりは問題ではないなーと思ってたのですが，
実はOSS用のリポジトリに対して使おうとすると fork レポジトリからの pull-request では暗号化された環境変数は使えない!
という問題があって，これどうすかなぁーということにかなり悩まされました．
考えてみれば当たり前で，<code>echo $SECRET_VAR</code> とかした悪意あるPull Request が開かれたら簡単に漏れちゃいます．</p>

<p>そこで，いろいろ CI サービスを探ってると <a href="https://drone.io/">https://drone.io/</a> の OSS バージョン
<a href="https://github.com/drone/drone">https://github.com/drone/drone</a> を見つけました．</p>

<p>help (<a href="http://readme.drone.io/usage/secrets/">Secrets · Drone</a>) を読むと，
yaml ファイルのチェックサムとセクション分けによって(完璧ではないものの)安全に
秘密の環境変数をforkからのプルリクでも使えるようになっているようです．
完全に便利なので travis とか circle ci でもこの機能ほしい&hellip;</p>

<p>drone.io OSS バージョンは <a href="https://drone.io/">https://drone.io/</a> とは別物という感じで環境変数の扱い以外も
結構便利っぽく，drone.io も reviewdog はデフォルトでサポートしました．</p>

<p>ただ OSS で雑にGitHubに上げたサービスに対して使うケースでも drone.io
をどこかにホスティングしなくてはならないのが不便なところです&hellip;
個人的にはreviewdogのために Degital Ocean に月500円で drone.io 用サーバを立ててみて，
今の所かなり便利感ありますが，ワガママをOSS用にどっかホスティングしてほしい.</p>

<p>で，じゃあ結局forkからのPull Requestも受け付けるOSS用リポジトリにreviewdog導入
したい場合どうすればいいかというと，現状は Circle CI の <a href="https://circleci.com/docs/fork-pr-builds/#unsafe-fork-pr-builds">Building Pull Requests from forks - CircleCI</a>
機能をセキュリティリスクと引き換えに ON にするしかないかなーという感じです．</p>

<p>GitHub の Personal Access Token, しかも scope を適切に <code>public_repo</code> とかに設定しておけば，
もし漏れても大したことはできないはずだし，rebokeもできるし，fork して悪意あるPull Request 作られたら流石に気付くし，
まぁそもそもそんなこと GitHub の 権限すくないPersonal Access Token 得るためにやる人は
少ないのでは&hellip; という感じですね．ただ使う場合はもちろん自己責任でお願いします．</p>

<p>Circle CI か travis あたりが drone.io みたいに yaml のチェックサム+環境変数が使えるスコープを制限する機能がもし実装されたらそれを使っていきたい</p>

<p>(ところで他のCIサービスとして wrecker 試したんですが，fork からの pull-request で普通に秘密の環境変数使えてしまった気がする&hellip;問題では&hellip;あとPull Request hook によるビルドがなさそうだった)</p>

<h3>終わりに</h3>

<p>reviewdog 完全に便利という感じなのでぜひ使ってみてください〜</p>

<p>CI 用環境変数とか設定すれば Jenkins とかいろんな環境で導入できるはずだし，
一度導入したら撤退しずらいとかもないので，ギョームとかでも使えるような気がしますが
リリース直後なのでいろいろ変わるかも知れないしそのへんはよしなにお願いします．
GitHub Enterprise とか BitBucket 対応は気が向いたらするかもしれない．
特にGitHub Enterprise はGitHub 用の base の url 変えるだけで対応できる&hellip;?</p>

<p>ちょくちょく気になるところはあるのでちまちま改善していこうかなーと思います</p>
</div>
  
  


      <footer>
      
      - <a href="/reviewdog/">reviewdog を飼ってコードレビューや開発を改善しませんか</a>
      <time datetime="2016-10-24T07:44:34+09:00" pubdate><span class='month'>Oct</span> <span class='day'>24</span> <span class='year'>2016</span></time>
      
      </footer>
    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/hatena-pepabo-kyoto/">はてな・ペパボ技術大会〜インフラ技術基盤〜@京都 行ってきたメモ</a></h1>
    
    
      <div class="post-meta">
        <p class="meta">
          <span class="timestamp">- 








  



<time datetime="2016-07-02T20:06:46+09:00" pubdate data-updated="true"></time> -</span>
          
        </p>
      </div>
    
  </header>


  <div class="entry-content"><h2>はてな・ペパボ技術大会〜インフラ技術基盤〜@京都 7/2</h2>

<p><a href="http://hatena.connpass.com/event/33521/">はてな・ペパボ技術大会〜インフラ技術基盤〜@京都 - connpass</a></p>

<p>行ってきました．メモってたのでせっかくなので共有しておきます．
gistでいいかとおもったけどスライド埋め込みとか考えたらブログに雑に投げたほうが見なおしやすそうと思ったのでブログで．
自分で発表したわけでもないし，感想とか書いてるわけでもないけどまぁいいかってカンジ．</p>

<h2>注意</h2>

<p>わかってない人が書いたメモなのでいろいろわかってないメモが書かれてます．
理解度に関係なく聞き漏らしたところ雑に書いたりしてるので発表様がおっしゃってた話とちがうところもあるかもしれない．
特に座談会の内容とかは Twitterのハッシュタグみてたら <a href="https://twitter.com/matsumotory">@matsumotory</a> さんと <a href="https://twitter.com/yumu19">@yumu19</a> さんがまとめてたのでそっち見たほうがわかりやすいかも．</p>

<h3>Togetter</h3>

<p><del><a href="http://togetter.com/li/994969">http://togetter.com/li/994969</a></del></p>

<p><del>ということで雑にtogetterつくっておきました．#pepabohatena で検索したやつからスパム2-3個消しただけです．
そういえばtogetterだめな人とかいるかもじゃん&hellip;!ということに気づいたんですが全員に連絡するの流石につらいのでダメなひと
<a href="https://twitter.com/haya14busa">@haya14busa</a> まで連絡していただければ幸いです．勝手に使って申し訳ないでした :bow: </del></p>

<p>記事書いてる間に @yumu19 さんが作ってた -> <a href="http://togetter.com/li/994986">はてな・ペパボ技術大会〜インフラ技術基盤〜@京都 #pepabohatena ツイートまとめ - Togetterまとめ</a></p>

<h3>タイムテーブル</h3>

<table>
<thead>
<tr>
<th>time </th>
<th> 名前 </th>
<th> タイトル </th>
<th> 時間</th>
</tr>
</thead>
<tbody>
<tr>
<td>13:30 </td>
<td>  </td>
<td> 受付開始・開場 </td>
<td> 30分</td>
</tr>
<tr>
<td>14:00 </td>
<td> y_uuki(はてな) </td>
<td> 開会宣言・会場説明 </td>
<td> 5分</td>
</tr>
<tr>
<td>14:05 </td>
<td> y_uuki(はてな) </td>
<td> はてなにおけるLinuxネットワークスタックの性能改善 </td>
<td> 25分</td>
</tr>
<tr>
<td>14:30 </td>
<td> matsumotory(ペパボ) </td>
<td> Webサービス基盤の自律制御と動的平衡性 </td>
<td> 25分</td>
</tr>
<tr>
<td>14:55 </td>
<td>  </td>
<td> 休憩 </td>
<td> 5分</td>
</tr>
<tr>
<td>15:00 </td>
<td> ichirin2501(はてな) </td>
<td> 計算量と僕とWeb開発 </td>
<td> 25分</td>
</tr>
<tr>
<td>15:25 </td>
<td> pyama(ペパボ) </td>
<td> STNS 〜点と線を結び新しい何かを作るコト〜 </td>
<td> 25分</td>
</tr>
<tr>
<td>15:50 </td>
<td>  </td>
<td> 休憩 </td>
<td> 5分</td>
</tr>
<tr>
<td>15:55 </td>
<td> masayoshi(はてな) </td>
<td> 負荷分散技術を選ぶ時に考えること </td>
<td> 25分</td>
</tr>
<tr>
<td>16:20 </td>
<td> monochromegane(ペパボ) </td>
<td> サービスに寄り添うログ基盤 - ログ収集のその先に - </td>
<td> 25分</td>
</tr>
<tr>
<td>16:45 </td>
<td>  </td>
<td> 休憩 </td>
<td> 10分</td>
</tr>
<tr>
<td>16:55 </td>
<td> masayoshi(はてな) taketo957(はてな) alotofwe(ペパボ) hanazuki(ペパボ) モデレータ stanaka(はてな) </td>
<td> 若手インフラ座談会 </td>
<td> 40分</td>
</tr>
<tr>
<td>17:35 </td>
<td>  </td>
<td> 懇親会 軽食と飲み物を用意しています！ </td>
<td></td>
</tr>
<tr>
<td>19:00 </td>
<td>  </td>
<td> お開き</td>
<td></td>
</tr>
</tbody>
</table>


<h2>開会宣言・会場説明</h2>

<p>14:00 | y_uuki(はてな) | 開会宣言・会場説明 | 5分</p>

<ul>
<li>発表6本+座談会</li>
<li>アンケート</li>
</ul>


<h2>はてなにおけるLinuxネットワークスタックの性能改善</h2>

<p>14:05 | y_uuki(はてな) | はてなにおけるLinuxネットワークスタックの性能改善 | 25分</p>

<p><a href="https://speakerdeck.com/yuukit/linux-network-performance-improvement-at-hatena">はてなにおけるLinuxネットワークスタックパフォーマンス改善 / Linux network performance improvement at hatena // Speaker Deck</a></p>

<script async class="speakerdeck-embed" data-id="1c0ab465dca74bc7b0f955cb6955ba8a" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>


<ul>
<li>はてなのウェブオペレーションエンジニア．新卒1年目の仕事</li>
<li>今は3年目</li>
<li>3層構成 LB <-> proxy <-> application <-> database</li>
<li>ボトルネックどこ?

<ul>
<li>CPU: %user/%sys/%iowait</li>
<li>Mem: used/cached/buffer</li>
<li>Disk: read/write</li>
<li>NW: tx/rx/tx</li>
</ul>
</li>
<li>ソフト割り込み(パケット受信)の負荷が高いときの話 (%soft)</li>
<li>ネットワークスタック

<ul>
<li>ネットワークi/oを実現するために必要な要素群．低レイヤより

<ul>
<li>NIC/パケット送受信/etc&hellip;</li>
</ul>
</li>
</ul>
</li>
<li>ネットワークI/O 高速化</li>
<li>パケット受信フロー  NIC -> Kernel -> Process

<ul>
<li>この辺の話かな? <a href="https://access.redhat.com/documentation/ja-JP/Red_Hat_Enterprise_Linux/6/html/Performance_Tuning_Guide/s-network-packet-reception.html">8.3. パケット受信の概要</a></li>
<li><img src="https://access.redhat.com/documentation/ja-JP/Red_Hat_Enterprise_Linux/6/html/Performance_Tuning_Guide/images/packet-reception.png" alt="" /></li>
<li>NIC: 物理デバイス</li>
<li><a href="https://ja.wikipedia.org/wiki/%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E3%82%AB%E3%83%BC%E3%83%89">ネットワークカード - Wikipedia</a></li>
<li>NIC ->(ハード割り込み) -> パケット受信 -> プロトコル処理 -> データ受信処理 -> Process</li>
<li>割り込み2種類ある．なぜか?</li>
<li>ハード割り込みだけだとパケット受信のたびにプロトコル処理まで実行しちゃう</li>
<li>なので一旦バッファにいれる．ソフト割り込み</li>
</ul>
</li>
<li>NAPI (New API)

<ul>
<li>1パケットずつでなく複数パケットごとに割り込み</li>
<li>ポーリングによってとってくる．待ち時間発生するので負荷が高い時だけやるみたいに賢くなってる</li>
<li>ソフト割り込みを減らす</li>
</ul>
</li>
<li>HAProxy の台数増問題 (実際に取り組んだやつ)</li>
<li>割り込みが多い -> 割り込み減らしたい</li>
<li>HAProxy のネットワーク負荷が高いのでHAProxyを DNS RR で並べた</li>
<li>Interrupt Coalescing

<ul>
<li>ハード割り込みを減らす</li>
</ul>
</li>
<li>NICドライバのパラメータ検証した</li>
<li>RPS (Receive Packet Steering)

<ul>
<li>コア間割り込み</li>
</ul>
</li>
<li>RPS でRedisチューニング

<ul>
<li>Redisは1スレッド</li>
<li>カーネルのネットワークI/O処理するスレッドと Redisのスレッドは分散可能</li>
<li>-> CPU% 10% 減 (コンテキストスイッチが減ったり，キャッシュが効くようになったからっぽい)</li>
<li>redisの公式ページにやりかた書いてある <a href="http://redis.io/topics/benchmarks">http://redis.io/topics/benchmarks</a></li>
</ul>
</li>
<li>ユーザランドへゼロコピー

<ul>
<li>そもそもカーネルに処理しないという変態処理．</li>
<li>パケットを NIC -> ユーザランドへバイパス</li>
<li>実装: netmap</li>
<li>まだ実用ではなさそうだけど研究されてる</li>
<li>ソケットAPIの限界

<ul>
<li>ソケットAPIではゼロコピーできない</li>
</ul>
</li>
</ul>
</li>
<li>まとめ

<ul>
<li>OSの内部面白い．OS内部の技術の外出し</li>
<li>ソフト割り込みにより遅延処理</li>
<li>ジョブキューのような非同期処理</li>
<li>割り込みとポーリング</li>
<li>OSの技術をもうちょっと上のレイヤの技術に応用してやったりするのベンリ</li>
</ul>
</li>
</ul>


<h2>Webサービス基盤の自律制御と動的平衡性</h2>

<p>14:30 | matsumotory(ペパボ) | Webサービス基盤の自律制御と動的平衡性 | 25分</p>

<script async class="speakerdeck-embed" data-id="60124a9e42bf4939b3d64687ef266d5c" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script>


<ul>
<li>@matsumotory <a href="http://research.matsumoto-r.jp/">松本亮介の研究・開発業績ページ by matsumoto-r</a></li>
<li>技術基盤チームで研究開発してる</li>
<li>目次

<ul>
<li>なめらかなシステム</li>
<li>Webサービスの現状・課題</li>
<li>自立制御</li>
<li>動的平衡性</li>
</ul>
</li>
<li>なめらかなシステム

<ul>
<li>システムにとってのユーザ，システムを構成するサーバ等の要素のカテゴリや特徴を詳細に認識する</li>
<li>人間の労苦は避けたい</li>
</ul>
</li>
<li>Webサービスの現状・課題

<ul>
<li>bad UI / 遅い / etc&hellip; -> 快適に利用できるのが当たり前</li>
<li>サーバの運用大変

<ul>
<li>高負荷・障害対応</li>
<li>問い合わせ</li>
<li>バジョンアップ</li>
<li>監視</li>
<li>新規構築</li>
</ul>
</li>
</ul>
</li>
<li>監視に注目してみる

<ul>
<li>閾値設定はムズカシイ</li>
<li>1時的な高負荷は無視したい．すぐもどるならok</li>
<li>傾向が変わるならすぐ知りたい</li>
<li>正常にみえるけど異常っぽいものを検知したい</li>
<li>段階的な傾向の変化を検知したい．階段みたいな．でも1時的なものは無視</li>
</ul>
</li>
<li>詳細な変化と原因を知るには人の目が必要．でも自動で制御したい

<ul>
<li>人は何をみてるか? 対象の振る舞いをみてる</li>
<li>振る舞いを表す特徴が知りたい!</li>
<li>人工知能でやれるか</li>
</ul>
</li>
<li>考え方

<ul>
<li>特徴がある</li>
<li>通常の状態を学習</li>
<li>外れた状態を解析</li>
<li>連速的に外れた状態が異常のはじまり</li>
</ul>
</li>
<li>各種基盤技術

<ul>
<li>[x] 設定をプログラム化</li>
<li>[x] リソース制御連携</li>
<li>[ ] 特徴量定義と解析 &lt;- ここ</li>
</ul>
</li>
<li>特徴量解析

<ul>
<li>変化点検出やクラスタリングなど研究はされている</li>
<li>mruby-changefinder <a href="https://github.com/matsumoto-r/mruby-changefinder">matsumoto-r/mruby-changefinder: ChangeFinder class detect change points via continuous outlier and smoothing.</a></li>
<li>複数データの関係性を得る</li>
</ul>
</li>
<li>Webサーバの自律制御

<ul>
<li>特徴量抽出による検知できる点の増加</li>
<li>閾値以下でも傾向変化の細かい検知ができる</li>
</ul>
</li>
<li>細かい傾向変化した時点でどうするか?

<ul>
<li>異常検知．誤検知もある．false positive/negative?</li>
<li>すぐ制限とかは影響でかい</li>
<li>なんかアクションはとりたい</li>
<li>システムとしてバランスを取りたい条件ある

<ul>
<li>マルチテナント環境とする．</li>
<li>リソースが逼迫してきたのみ制限かけたい．自動で制限したい．</li>
<li>グラフなめらかにしたい．</li>
</ul>
</li>
<li>e.g.

<ul>
<li>どのホストが変化点スコアが高い?</li>
<li>重み付け (優先順位つける) example.com:95, matsumoto-r.jp:93, &hellip;</li>
<li>傾向変化ごとに重みつけリスト更新</li>
<li>全リソースが逼迫 -> リストを元に自動制御</li>
<li>逼迫してないなら重みつけリストをつくるところだけしとく</li>
</ul>
</li>
<li>時系列データの生成

<ul>
<li>相関関係の時系列データも作れる</li>
<li>全体の負荷とホストの負荷どっちか</li>
</ul>
</li>
</ul>
</li>
<li>要素技術

<ul>
<li>機能拡張 mod_mruby</li>
<li>mruby-resource</li>
<li>mruby-changefineder</li>
<li>etc&hellip;</li>
</ul>
</li>
<li>制限の実装方法

<ul>
<li>リクエスト単位でCPU/IOなどの割当を変更</li>
<li>cgroup/rlimit</li>
<li>e.g. 特定のcgroupにリクエストをアタッチしてCPUを20%に制限する．レスポンス返したらデタッチ</li>
</ul>
</li>
<li>ミドルウェアが特徴量抽出解析・制限行いたい</li>
<li>webサービスの動的平衡性

<ul>
<li>生命とは? 動的平衡にある流れ</li>
<li><blockquote><p>動的平衡（どうてきへいこう、英語：dynamic equilibrium）とは、物理学・化学などにおいて、互いに逆向きの過程が同じ速度で進行することにより、系全体としては時間変化せず平衡に達している状態を言う。
&ndash; <cite><a href="https://ja.wikipedia.org/wiki/%E5%8B%95%E7%9A%84%E5%B9%B3%E8%A1%A1">動的平衡 - Wikipedia</a></p></blockquote></li>
<li><a href="https://ja.wikipedia.org/wiki/%E7%B4%B0%E8%83%9E%E5%91%A8%E6%9C%9F%E3%83%81%E3%82%A7%E3%83%83%E3%82%AF%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88">細胞周期チェックポイント - Wikipedia</a>

<ul>
<li>細胞: さーば</li>
<li>動的平衡: サーバの構築と破壊</li>
<li>Web サービス基盤を生命のように扱う

<ul>
<li>異常・エントロピー増大からは逃れられない</li>
<li>自分で自らを破壊・増殖・再構築していく</li>
<li>一つ一つの細胞の調子わるいな?とかは僕らだってみてない．1部変でも全体としては大丈夫．</li>
</ul>
</li>
<li>詳しくは: <a href="https://speakerdeck.com/matsumoto_r/namerakad-idea-design">なめらかなシステムのアイデアと設計概要 / namerakad-idea-design // Speaker Deck</a>
<script async class="speakerdeck-embed" data-id="51e39a56e84e4b79a957f653b8c941d0" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script></li>
</ul>
</li>
</ul>
</li>
<li>今後: STNS/haconiwa, &hellip;</li>
<li>Q&amp;A:

<ul>
<li>フォールトトレランスとの違い?

<ul>
<li>現時点はそこまで．循環するパターン．状態を持つサーバと持たないサーバがある．この辺とかの落とし所を考えてる</li>
</ul>
</li>
<li>from yuuki: Docckerとかで動的にスケールしてるけど，違うアプローチっぽい．どう違う? キューバネティスとか?

<ul>
<li>こちらはサーバを積極的に，自主的に落として循環していくといった部分が違う．元気なサーバでも任意の時間経過で落としたり．</li>
</ul>
</li>
<li>from astj: バースト．イベントやyahoo砲とかのバズり，が怖い．これを異常検知するのはむずくてなかなか考えても答えが出ない．自律制御のスピード超えてバースト来たらどうする?

<ul>
<li>全体的にはバーストに対応したい．落とす条件．3時間で落ちそうなやつが1.5時間で落ちたなら1つではく2つのVMを再構築するといった方法あるかも．落としたときに条件によって10倍再構築するとか．</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>netflix とかも似たようなことやってる感じらしい?</p>

<p>mackerel で出来たりしたら最高だな〜と思った．</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">なめらかなシステムのシミュレーションはこれを見るとわかりやすいです <a href="https://t.co/PK3jn4cJvi">https://t.co/PK3jn4cJvi</a> <a href="https://twitter.com/hashtag/pepabohatena?src=hash">#pepabohatena</a></p>&mdash; 松本 亮介 / まつもとりー (@matsumotory) <a href="https://twitter.com/matsumotory/status/749135118095163394">July 2, 2016</a></blockquote>


<h2>計算量と僕とWeb開発</h2>

<p>15:00 | ichirin2501(はてな) | 計算量と僕とWeb開発 | 25分</p>

<ul>
<li>@ichirin2501 いちりんちゃんさん

<ul>
<li>アプリケーションエンジニア2年 ->(転職) web オペレーションエンジニア1年(hatena)</li>
<li>スピリチュアルな発表!</li>
</ul>
</li>
<li>もくじ

<ul>
<li>計算量について</li>
<li>mysql クエリ改善</li>
</ul>
</li>
<li>計算量とは?

<ul>
<li>大変さの指標．</li>
<li>係数無視 O(3n<sup>3</sup>) -> O(n<sup>3</sup>)</li>
<li>でかいやつだけ O(n<sup>3</sup> + n<sup>2</sup>) -> O(n<sup>3</sup>)</li>
</ul>
</li>
<li>計算量といちりんちゃん

<ul>
<li>競プロで向き合う．</li>
<li>計算量と時間の基準・感覚がある</li>
<li>O(10<sup>7</sup>) ~ O(10<sup>9</sup>) 0 -> 1s くらいじゃん?みたいな感じ</li>
<li>データサイズからの見積もり

<ul>
<li>1sec デッドラインの見積もりならこんな感じやろ的な．</li>
<li>n &lt;= 10<sup>6</sup> -> O(n)</li>
<li>n &lt;= 10<sup>5</sup> -> O(nlogn)</li>
<li>n &lt;= 3000 -> O(n<sup>2</sup>)</li>
<li>n &lt;= 100 -> O(n<sup>3</sup>)</li>
<li>n &lt;= 20 -> O(2<sup>n</sup>)</li>
</ul>
</li>
</ul>
</li>
<li>MySQL 改善のはなし

<ul>
<li>group by / distinct の迷い．どっちでも重複除外できるので実現可．

<ul>
<li>follow/followerテーブル的なものを想定</li>
<li>friend_id 重複なしで 1000件ほしい</li>
<li>結果を言うと group by だと遅いケースがあった</li>
<li>group_by で OR句のuser_idが多いと異常におそくなった</li>
<li>どう計算してるか知ればいいじゃん</li>
</ul>
</li>
<li>インデックス構造

<ul>
<li>インデックス B+tree</li>
<li>主キーのインデックス clustered index</li>
<li>主キー以外のインデックス secondary index (主キーがこれでわかる)</li>
<li>B+tree はleafが連結リスト．rangeで検索とかのときにベンリ</li>
<li>例とか．この辺発表の図をみるとわかりやすくてベンリ</li>
</ul>
</li>
<li>話をもどしてfriend_id. なぜ遅いのか?

<ul>
<li>オーダーが違うかも</li>
<li>意図してないインデックスで検索してるかも -> オーダー線形なってるかも</li>
</ul>
</li>
<li>結論そうだった

<ul>
<li>explainするとわかる</li>
<li>オプティマイザが間違った判断してた(あるある．経験則). distinct だと解決した</li>
<li>経験則やexplain使わなくても計算量と時間の感覚でどこがまずそうかわかることもあるよ!

<ul>
<li>ミドルウェアのどのへんが悪いかとか計算量の感覚やインデックスの使われ方を理解して推測したり出来るとベンリ</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Redis の話

<ul>
<li>redis とか

<ul>
<li>kvs nosql(ほかにもグラフデータベースとかあるよねー)</li>
<li>list/set/sorted sets(rankingの実装らくとか)/etc .. データ構造いっぱいあってベンリ</li>
<li>メモリ最適化 2.2 から入ってる．勝手に圧縮してもらえる

<ul>
<li>-> パラメータ眺めてオーダーとか変わったりするのでは?と推測</li>
</ul>
</li>
</ul>
</li>
<li>怪しいのでパラメータ変えて実際試す

<ul>
<li>データ数と実行時間からオーダーわかる</li>
<li>データ数10kで1 sec超えるのオカシイのではと気づく．</li>
</ul>
</li>
<li>やっぱり -> データ構造違ってた

<ul>
<li>ドキュメントに実は書かれてたりも．</li>
</ul>
</li>
</ul>
</li>
<li>まとめ

<ul>
<li>知識だけじゃなく感覚を身に着けてるとすぐわかったりしてベンリ．現場で検証しまくるとかできなかたったりするし．</li>
<li>まつもとりーさんも言ってたが快適にウェブサービス使えるのは当たり前だし，この辺にコミットするために計算量ベンリ</li>
</ul>
</li>
<li>Q&amp;A

<ul>
<li>from yuuki: このへんミスったりすると自律制御したりしても一瞬でリソース食いつぶしたりするし，このへん自律制御するのどうするかとかもおもしろそう</li>
</ul>
</li>
</ul>


<p>べんり <a href="http://gigamaker.jimdo.com/">ホーム - 鳥獣戯画制作キット</a></p>

<p>計算量の感覚大事．</p>

<h2>STNS 〜点と線を結び新しい何かを作るコト〜</h2>

<p>15:25 | pyama(ペパボ) | STNS 〜点と線を結び新しい何かを作るコト〜 | 25分</p>

<ul>
<li>やましたさん． @pyama86

<ul>
<li>ムームードメインやってる</li>
</ul>
</li>
<li>Linux のユーザ管理

<ul>
<li>いつから LDAP 主流だと錯覚してい(ry</li>
</ul>
</li>
<li>最近のユーザ管理

<ul>
<li>root おおい．</li>
</ul>
</li>
<li>rootは問題あるよね

<ul>
<li>セキュリティ事故の追跡</li>
<li>sudo権限の分離</li>
<li>userの追加削除管理困難．追加でポリシーのため他のサーバにも足す&hellip;とかやるとこまる．</li>
<li>rootはアブナイ!!!</li>
</ul>
</li>
<li>でもなぜやってしまうか

<ul>
<li>なにかあったときしか困らない</li>
<li>まぁLDAP構築たいへんだよねとかある．</li>
</ul>
</li>
<li>STNS で解決!

<ul>
<li><a href="https://github.com/STNS/STNS">STNS/STNS: Simple Toml Name Service</a></li>
<li>名前解決/公開鍵取得/アカウント認証のみを提供．LDAPはいろいろできすぎて困る．</li>
<li>ls -ltr の名前は実はid. pyama -> id:1000 ．これが名前解決</li>
</ul>
</li>
<li>デプロイユーザの管理できる

<ul>
<li>capistorano とか公開鍵たしてsshでやるよね．authorized_keys 管理だるくなるよね．</li>
<li>stnsだとスッキリ!誰がdeployできるか一目瞭然でよい．</li>
</ul>
</li>
<li>組織構造を表現できる

<ul>
<li>group</li>
</ul>
</li>
<li>シュッとインストールできるよ! 2.5min</li>
<li>事例

<ul>
<li>pepaboさん事例．ユーザ管理もgithub flowで. ghe でpr -> droneでテスト &amp; レビュー -> deploy</li>
<li>承認してマネージャーが承認して&hellip;とかめんどくてそれ解決できてベンリ．エンジニアで管理</li>
<li>ghe で全部管理できるので入退社管理とかも楽</li>
</ul>
</li>
<li>プロダクトを運用すること

<ul>
<li>ヒントとなった技術からアイデア得たり</li>
<li>mackerelのtomlとかgo使ってるやつ参考にしたり</li>
<li>linuxで利用可能な共通ライブラリがgo1.5から作れるようになってこれがでかい．Cを書かなくてもLinuxのシステムに手を入れられる</li>
<li>自分が開発者だし自分がSTNSを最高にできる!!!</li>
</ul>
</li>
</ul>


<p>LDAP とかユーザ管理あんまり関わってないけど便利そうだった．良い話きけて良い．</p>

<ul>
<li>Q&amp;A:

<ul>
<li>from yuuki: hatena は LDAP だけどSTNSよさそう!</li>
</ul>
</li>
</ul>


<h2>負荷分散技術を選ぶ時に考えること</h2>

<p>15:55 | masayoshi(はてな) | 負荷分散技術を選ぶ時に考えること | 25分</p>

<p><a href="https://speakerdeck.com/masayoshi/fu-he-fen-san-ji-shu-woxuan-butokinikao-erukoto-1">負荷分散技術を選ぶときに考えること // Speaker Deck</a></p>

<script async class="speakerdeck-embed" data-id="4069267887dd401c93e8fe6b1de08f34" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>


<ul>
<li>masayoshi @yoyogidesaiz

<ul>
<li>新卒．めでたい．</li>
<li>SDN(Software-Defined Networking) 大学でやってた <a href="http://e-words.jp/w/SDN.html">SDNとは｜Software-Defined Networking - 意味/定義 ： IT用語辞典</a></li>
</ul>
</li>
<li>負荷分散技術の概要

<ul>
<li>データセンター分散したり</li>
<li>ロードバランサーでbackend web分散したり</li>
<li>サーバ内/ロールごと/サーバごと のだいたい3つの分散ある</li>
</ul>
</li>
<li>サーバ内リソースの負荷分散

<ul>
<li>ハードウェア機能: hyper-threading, raid0</li>
<li>ハードウェア意識のOSの負荷分散: numa, rss/rfs/rps</li>
<li>OS意識のアプリケーションの作り方: fork()/clone() などのシステムコール</li>
<li>Numa <a href="https://ja.wikipedia.org/wiki/NUMA">NUMA - Wikipedia</a>

<ul>
<li><blockquote><p>NUMA（Non-Uniform Memory Access、ヌマ）とは、共有メモリ型マルチプロセッサコンピュータシステムのアーキテクチャのひとつで、複数プロセッサが共有するメインメモリへのアクセスコストが、メモリ領域とプロセッサに依存して均一でないアーキテクチャである
&ndash; <cite><a href="https://ja.wikipedia.org/wiki/NUMA">NUMA - Wikipedia</a></p></blockquote></li>
</ul>
</li>
<li>application

<ul>
<li>fork() プロセス</li>
<li>clone() スレッド</li>
<li>select() プロセス &lt;- x (io多重化とかに影響するだけでCPUには影響しない?)</li>
<li>このへんいろいろ理解してアプリケーションコードかく! (なるほど)</li>
</ul>
</li>
</ul>
</li>
<li>ロールごとの分散

<ul>
<li>proxy/web/db などのロールの分散</li>
<li>proxyでキャッシュしたり，全部のリクエストがdbまで到達しないようにとか</li>
<li>キャッシュ

<ul>
<li>ユーザに近いところで返す</li>
<li>キャッシュヒットしなくて破綻とか実装に無理があったりとかもする．</li>
<li>-> 使いどころを見極める．キャッシュは麻薬</li>
</ul>
</li>
</ul>
</li>
<li>サーバごとの負荷分散

<ul>
<li>この辺がインフラエンジニアに特にやりがいあったり</li>
<li>拠点ごとに分散．</li>
<li>load balancerでパケットを分散</li>
<li>負荷分散技術を実現するために分散システムの考え方を参考にしたり</li>
<li>透過性: <a href="https://ja.wikipedia.org/wiki/%E9%80%8F%E9%81%8E%E6%80%A7_(%E6%83%85%E5%A0%B1%E5%B7%A5%E5%AD%A6">透過性 (情報工学) - Wikipedia</a>)</li>
<li>DNSラウンドロビン

<ul>
<li>位置透過性を実現</li>
</ul>
</li>
<li>ロードバランサ

<ul>
<li>位置透過性実現</li>
<li>ヘルスチェックできる</li>
<li>でもネットワークの制限受けたり</li>
</ul>
</li>
<li>Proxy

<ul>
<li>haproxy/nginxなど</li>
<li>ヘルスチェックできるし位置透過性も高い</li>
</ul>
</li>
<li>分散先ノードのヘルスチェック

<ul>
<li>監視: how?</li>
<li>異常(どんな?)のあるノードを削除</li>
</ul>
</li>
<li>ヘルスチェックむずい．

<ul>
<li>OK返してるの本当ok? 中身見たら実はngとか</li>
<li>ビザンチン将軍問題．<a href="https://ja.wikipedia.org/wiki/%E3%83%93%E3%82%B6%E3%83%B3%E3%83%81%E3%83%B3%E5%B0%86%E8%BB%8D%E5%95%8F%E9%A1%8C">ビザンチン将軍問題 - Wikipedia</a></li>
<li>Gossip protocol <a href="http://www.slideshare.net/winebarrel/ss-10433600">ゴシッププロトコルによる冗長化と負荷分散の検証</a></li>
<li><a href="http://qiita.com/hshimo/items/b7c0e0f12b7363e2e333">分散型コンセンサス・アルゴリズム プロトコル まとめ - Qiita</a></li>
</ul>
</li>
<li>ロードバランサの耐障害性

<ul>
<li>冗長化技術であって負荷分散技術ではない</li>
</ul>
</li>
</ul>
</li>
<li>まとめ

<ul>
<li>負荷分散の仕方まとめ</li>
<li>必要以上に複雑にしない．コスト増とかもある．simple is best</li>
<li>本当に必要なのか最高する</li>
<li>オープンソースカンファレンスはてなでブースだす． <a href="http://www.ospn.jp/osc2016-kyoto/">オープンソースカンファレンス2016 Kyoto - オープンソースの文化祭！</a></li>
</ul>
</li>
<li>Q&amp;A

<ul>
<li>どこが負荷おおいか?

<ul>
<li>disk がおおい．dbとか．ロールごとに分けておいてキャッシュ聞かせていく戦略おおい．(計算機の仕組み的にdiskがおそい from yuuki)．最近iodriveとかあって速くなってきてるのでスケールアップが多い．</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2>サービスに寄り添うログ基盤 - ログ収集のその先に -</h2>

<p>16:20 | monochromegane(ペパボ) | サービスに寄り添うログ基盤 - ログ収集のその先に - | 25分</p>

<p><a href="https://speakerdeck.com/monochromegane/pepabo-log-infrastructure-bigfoot">サービスに寄り添うログ基盤/pepabo_log_infrastructure_bigfoot // Speaker Deck</a></p>

<script async class="speakerdeck-embed" data-id="5afe99df3d13476d8fd631d22d83d393" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script>


<ul>
<li>monochromegane

<ul>
<li>minne</li>
<li>普段 rails 書いてる．最近ログ基盤の開発してる．</li>
</ul>
</li>
<li>ログはいいぞ!

<ul>
<li>ログはウェブサービスにおいて重要</li>
</ul>
</li>
<li>行動ログ

<ul>
<li>アプリケーション層で出力するログ(apacheのログとかではない)</li>
<li>いつ，だれが，なにをやったか特定できる</li>
<li>最終結果だけでなく，どこであきらめたか．どう迷ったかが分かる

<ul>
<li><blockquote><p>特にどこであきらめたか．どう迷ったかが分かるところにサービス改善のヒントが詰まってる!!!</p></blockquote></li>
</ul>
</li>
</ul>
</li>
<li>行動ログ活用段階

<ul>
<li>収集: とりあとめる</li>
<li>分析: 視覚化したり分析</li>
<li>活用: 分析結果を使って継続的なサービス改善</li>
<li>&ldquo;ログの活用&rdquo;

<ul>
<li>ログがたまるだけとか，グラフでてバンザイ！するだけではだめ!!</li>
</ul>
</li>
<li>-> ログの<strong>活用</strong>基盤をつくる!</li>
</ul>
</li>
<li>Bigfoot

<ul>
<li>ペパボの次世代ログ<strong>活用</strong>基盤</li>
<li>minnneのそれでもある．</li>
<li>UID 振る．アプリでログを吐いて集約基盤へ -> 分析 -> サービス改善など活用</li>
</ul>
</li>
<li>Bigfoot を支える技術

<ul>
<li>ログを送る

<ul>
<li>fluentd rack-bigfoot(rails) OSS的な感じではなさそうか&hellip;?</li>
</ul>
</li>
<li>集約基盤 Treasure Data

<ul>
<li>活用に力入れたかったので集約基盤はとりあえずTDに任せた．あとで自社のものにするかも</li>
<li>Hive QL. 行動ログをSQLライクに扱える</li>
</ul>
</li>
<li>ワークフロー

<ul>
<li>tdのスケジュールクエリを利用．これはwebのコンソールからorAPI.APIだと個々人が勝手にいろいろできたりしてこまる</li>
<li>-> クエリのコード管理にpendulum <a href="http://blog.monochromegane.com/blog/2016/03/21/pendulum/">Treasure Dataのスケジュールジョブをコードで管理するPendulumというgemをつくった · THINKING MEGANE</a></li>
<li>コードレビューとか管理できてよい</li>
<li>digdag というtd社公式のものがあるので移行中 <a href="https://github.com/treasure-data/digdag">treasure-data/digdag: Workload Automation System</a></li>
</ul>
</li>
<li>属性情報

<ul>
<li>行動ログのidから性別などなど属性情報を組み合わせると分析の幅が広がる</li>
</ul>
</li>
<li>名寄せ

<ul>
<li>サービスのアカウントと各クライアントをマッピング</li>
<li>未ログイン状態のアカウントも名寄せ後に過去に遡って紐付け</li>
<li>cookie syncと組み合わせてサービス間の紐付け</li>
</ul>
</li>
<li>Big Cube とCube

<ul>
<li>BigCube: 全サービスの行動ログを集約してる</li>
<li>切り口が確定したらCubeに切り出す(cubeに切り出されるとpostgresに入るので速く集計できたりする)</li>
</ul>
</li>
<li>視覚化と分析

<ul>
<li>pivot tableのすごいやつ． Tableau社のTableau Desktopを使う <a href="http://www.tableau.com/ja-jp/products/desktop">Tableau Desktop | Tableau Software</a></li>
<li>データソースとしてtdつかえる</li>
</ul>
</li>
<li>活用

<ul>
<li>画面デザインの変更．ステップ見直し</li>
<li>A/Bテスト</li>
<li>-> 静的なフィードバック．人が判断．固定化する．</li>
</ul>
</li>
<li>動的なフィードバックがよいのでは?

<ul>
<li>システムが行動ログを吐く -> 変換したものをシステムが受け取る -> 挙動を変える</li>
<li>バンディットアルゴリズム

<ul>
<li>いまやってみてる．</li>
<li>A/Bテストの機会損失減らしてる．</li>
<li><a href="https://www.oreilly.co.jp/books/9784873116273/">O&#8217;Reilly Japan - バンディットアルゴリズムによる最適化手法</a></li>
<li>強欲な感じで期間内の最良の手法を探す．最大はそれにbetする(活用)が他のものにもbet(探求)．</li>
</ul>
</li>
<li>リコメンド

<ul>
<li>matrix factorization</li>
<li>強調フィルタリングの一種</li>
<li>tdのなんかでできるらしい?</li>
</ul>
</li>
</ul>
</li>
<li>browse,card abondonment</li>
</ul>
</li>
<li>サービスに寄り添うログ基盤

<ul>
<li>単に集めるだけじゃなくて分析，活用の段階を補助する</li>
<li>静的フィードバックから動的フィードバックへ</li>
<li>行動ログの循環によって<strong>なめらかな世界</strong>へ．ということでログはいいぞ</li>
</ul>
</li>
<li>Q&amp;A

<ul>
<li>Q「送る側のサービスからログ基盤への負荷の問題はどうか」A「fluentdがよく出来ているから問題ない」 <a href="https://twitter.com/matsumotory/status/749151437850980352">https://twitter.com/matsumotory/status/749151437850980352</a></li>
<li>Q「fluentd自体の負荷はどうか」A「ない、今の設計規模では大丈夫」もともとfluentd自体はつかってて大丈夫ならしい</li>
<li>td負荷? ログを送りつけるぶんには負荷は気にしなくて良い．送ったあとにインデックス使わずに集計したりするとまずい．プランやすかったりすると特に．</li>
</ul>
</li>
</ul>


<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">これ、みやけさんほぼ一人でやってたからやばすごなんですよ… <a href="https://twitter.com/hashtag/pepabohatena?src=hash">#pepabohatena</a></p>&mdash; 松本 亮介 / まつもとりー (@matsumotory) <a href="https://twitter.com/matsumotory/status/749146241422860288">July 2, 2016</a></blockquote>


<p>まじか&hellip;</p>

<p>活用を重要視していてよさそう．おもしろい話だった．</p>

<p>「ログはいいぞ」．</p>

<h2>若手インフラ座談会</h2>

<p>16:55 | masayoshi(はてな) taketo957(はてな) alotofwe(ペパボ) hanazuki(ペパボ) モデレータ stanaka(はてな) | 若手インフラ座談会 | 40分</p>

<ul>
<li>新卒1,2年目の人達で座談会．stanakaさん仕切ってる</li>
<li>自己紹介

<ul>
<li>taketo957: hatena. 新卒．インフラしてる． <a href="https://twitter.com/taketo957">taketo957 (@taketo957) | Twitter</a></li>
<li>masayoshi: hatena. 新卒．さっき発表した <a href="https://twitter.com/yoyogidesaiz">まさよし (@yoyogidesaiz) | Twitter</a></li>
<li>hanazuki: pepabo. 大学京都．インフラしてる．渋谷．去年入社 <a href="https://github.com/hanazuki">hanazuki (Kasumi Hanazuki)</a></li>
<li>alotofwe: pepabo. 読み方:すずぴー．ねっとではれいか??? 去年入社．競プロ学生からやってる <a href="https://twitter.com/alotofwe">玲香@健康 (@alotofwe) | Twitter</a></li>
</ul>
</li>
<li>なんでインフラ?

<ul>
<li>masayoshi: ネットワーク系の研究してたり．かっこいいじゃん?</li>
<li>hanazuki: KMC入ってた．サーバーいじったりするの楽しかった．</li>
<li>taketo957: B3くらいでRailsやってたらブラックボックスおおくていろいろ調べてた．京都ならはてなでインフラできそうということでアルバイトしてisuconしたりなどなど．面白くてそういう形式で入社した．</li>
<li>alotofwe: 大学時代はそんなにインフラしてたわけじゃなかった．アプリは書いていたけど，やっていてアプリはもういいやという感じになった．インフラorセキュリティやろうとおもって，セキュリティ志望だけどセキュリティするためにはインフラ知らなきゃだめなので今インフラやってる

<ul>
<li><ol type="a">
<li>せきゅりてぃ専門のひとpepaboにいる?</li>
</ol>
</li>
<li><ol type="a">
<li>ちょっといる．matsumotoryさんとかも?</li>
</ol>
</li>
<li>はてなではセキュリティ専門はいない．みんなでやる．</li>
</ul>
</li>
</ul>
</li>
<li>アプリとインフラの境界? たとえばDBへのクエリ，スキーマあたりの責任や分担とかどう?

<ul>
<li>masayoshi: 監視業務のアルバイトしてその時はじめてインフラやった．そのときはコード書いてる人はいなかった．DBの設計まではしないけど性能のチェック，クエリのパフォーマンスチェックなどはしてた．はてなでは? -> だいたい一緒．</li>
<li>taketo957: 入社以前はもっとハッキリした境界あると思ってたけど，入ってみたらアプリ側が一緒にやってくれたりとか．インフラはmiddle wareより下はだいたいみてる．</li>
<li>hanazuki: パフォーマンスチューニングとかが境界．どっちからもみる．上からみるか下からみるかって感じ．境界がハッキリはしてない．</li>
<li>alotofwe: だいたいhanazukiさんと同じ．開発のひとからpull-reqが飛んできてレビューするとかまであるくらい境界は曖昧．ある程度権限はあるけどソレ以外はほとんど境界はない．</li>
</ul>
</li>
<li>インフラエンジニアになって1-2年，おもしろかったことや印象的なエピソードとかある?

<ul>
<li>masayoshi: はてなはオンプレ環境ある．ネットワーク機器をみてエラーパケットとかみたりした．そこで傾向とかがみれて面白い</li>
<li>hanazuki: プライベートクラウド使ってる．チョット前まではオンプレ．仮想環境を使う側．awsを使うのとは違ってどう動かすかとかツールとか作っていく．この辺が楽しい</li>
<li>taketo957: いろいろわかってきて嬉しい!</li>
<li>alotofwe: 推理小説がスキ．障害の何が原因か調べるのが探偵の推理っぽくて楽しい．</li>
</ul>
</li>
<li>研修でよかったこと

<ul>
<li>taketo957: 今年からインフラでも新卒研修．知識編と設計編．設計編がおもしろかった．実際に動いてるサービスにたいしてこのくらいのリクエストならどう設計するか．身になる部分でよかった．</li>
<li>hanazuki: 1ヶ月間くらい研修ある．内容自体はだいたい知ってたりもしたけど試行錯誤がおもしろかった．</li>
<li>alotofwe: 今年は研修作る側．内容: railsつくって運用基盤つくってmobileつくる．最低限の生き延びるための知識を得るようなもの．インフラのものはあまり知らなかったので特に勉強になった．</li>
<li>masayoshi: 全部taketoくんに言われた! ミドルウェアの組み合わせだけじゃなくて構築するとかコードを書いて作ってみるとどこがボトルネックになるのかとかわかったりする．作ったり構築・コード書くのも研修でやるとその辺に気づけて勉強になるのでベンリ．</li>
</ul>
</li>
<li>hatena は京都と東京．pepaboは福岡と東京にある．2拠点でやってることに関して感じることとか?

<ul>
<li>taketo957: 自分がやった話ではない．東京とのコミュニケーションコストを下げる．提示前15minのslack call雑談とかやってる．(yuukiさんが導入した)</li>
<li>masayoshi: taketoさんの続きってかんじ．今すぐ，まだまとまってないけど考えを話し合い，そういうときに音声チャットあってすぐに話せる環境があるとよい．ちょっと話したいけどいいですか?って聞いたらすぐ聞けるという環境が大事でベンリ．</li>
<li>taketo957: 補足．はてなは社内の文化的にこんなことも残すのか．というところまで残す．音声もベンリだけどチャットなどのテキストで何でも残すというところもよい．</li>
<li>hanazuki: みてるサービスが違うのでそこまでコミュニケーションをする必要はそもそもない．週1でビデオコールとかしてる．コミュニケーションとりたいけど取れないときもあるのでなんとかしたい．</li>
<li>alotofwe: slackべんり．アイコンが顔写真でよい．</li>
<li>masayoshi: アイコンもよいよね!</li>
<li>どうしても落ちがちな情報．手元で詰まってるけど大変とかいう情報とか．</li>
</ul>
</li>
<li>ロールモデル．将来どうなりたいとか．社内社外問わず目標としてる人とかいるか?

<ul>
<li>masayoshi: 具体的な人物とかはあんまりない．エンジニアとアカデミック系では本来あんまり境界はない．インフラのパフォーマンスチューニングとかは個人の技術という側面がおおいので体系化して学術分野にも広めたりアウトプットしたい．</li>
<li>taketo957: 入社したときはyuukiさんにあこがれてといった．ネットワーク周り喋ってるひとがおおい．アプリ観点から観てるひとはあんまりすくなさそう．研究室でやってきた人力でやる仕組みとか応用したりしていきたい．(クラウドソーシング?)</li>
<li>hanazuki: あんまり決まってない．人力の認知力でやったりするのはうっかりとかが発生して困るのでつらい．半分寝てても仕事できるようにしたい</li>
<li>alotofwe: よくばりさんなので側面によって尊敬してる人が異なる．つまみ食いしていきたい．食べてる最中なのであんまり決まってない．</li>
</ul>
</li>
<li>インフラエンジニアの醍醐味?．会社のいいところは?

<ul>
<li>taketo957: レイヤーが下がるにつれて相手にするものが多くなる．それにつれて自分の知識も増やす必要がある．いろんな知識を裏側まで見通してやっていったりするのは面白い．会社のよいところ．新しい技術・古い技術と幅がでていてよい．</li>
<li>masayoshi: 基盤をつくるのが面白い．大規模なものを支えるところが面白い．裏方だけど支えがないと動かない．このアラート放置していいんすか?とか聞くと先輩とかが話してくれて一緒に解決してくれたり．</li>
<li>hanazuki: インフラといってもハードウェアみたりチューニングしたりなどいろいろな分野・仕事がある．いろいろできるのよい．それぞれスキなレイヤで改善できるところとかよい．</li>
<li>alotofwe: アプリと比較．アプリ開発だと適当に書いても動いちゃう．インフラだと1行追加すると大きい影響があってじっくり考慮してかかなきゃだめだったりする．向上心強い人がおおい．よくしていきたいという気持ち．勉強しやすい会社．</li>
</ul>
</li>
</ul>


<h2>僕の(雑)まとめ感想とか</h2>

<p>インフラ系のことはほとんどできていなくて，知識も全然ないけど，どんな感じでやってるのかなぁと興味はあったので参加しました．
アプリケーション書くときもインフラ意識して書くとよかったりするのでインフラエンジニアとかウェブオペレーションエンジニアみたいな職種につかなくても知っておくと便利．
実際座談会の話では，はてなさんでもペパボさんでもアプリケーションエンジニアとインフラエンジニアの仕事の境界とかは曖昧で，上から見るか下から見るかの違い程度しかないみたいな話をしてた気がする．
僕も，もっとインフラ意識しながら開発していきたいなーという気持ち高まった．</p>

<p>ネットワーク周りだとシステムコールとかいろいろ正直よくわからんくて前提知識僕が持ってないんだなーという話は多かったけど，
わかんない話でもおもしろいなーと得られる部分あったり，割とまだ分かる話(相対的に)でも知らないことがたくさん学べたり，なるほどなーとかそうだよなーよいよい!という話ばかりで
どの発表もよくて来てよかった．</p>

<p>運営・発表者の皆さんありがとうございました．</p>

<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

</div>
  
  


      <footer>
      
      - <a href="/hatena-pepabo-kyoto/">はてな・ペパボ技術大会〜インフラ技術基盤〜@京都 行ってきたメモ</a>
      <time datetime="2016-07-02T20:06:46+09:00" pubdate><span class='month'>Jul</span> <span class='day'>02</span> <span class='year'>2016</span></time>
      
      </footer>
    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/archives">Blog Archives</a>
    
  </div><!-- /div.pagination -->
</div><!-- /div.blog-index -->

      </div><!-- /div#content -->
    </div><!-- /div#main -->
  </div><!-- /div.container -->
  <footer><div id="footer-widgets-wrapper">
  <div id="footer-first" class="footer-widget">
    <h3>About Me</h3>
    <section class="about-me">
      
        <img class="icon-image" src="https://0.gravatar.com/avatar/dca89778aa3e6bc49f0e100df1a1a1f0?s=240" alt="icon_image">
      
      <div>
        <ul>
          
            <li>GitHub: <a href="https://github.com/haya14busa">@haya14busa</a></li>
          
          
            <li>Twitter: <a href="https://twitter.com/haya14busa">@haya14busa</a></li>
          
            <li>Blog: <a href="http://haya14busa.com">http://haya14busa.com</a></li>
        </ul>
        <p>
          V!mm!shment Th!s World!
        </p>
      </div>
    </section>
  </div><!-- /div#footer-second -->

  <div id="footer-second" class="footer-widget">
    <h3>Recent Posts</h3>
    <section id="hatena-popular" class="hatena-bookmark">
      <script language="javascript" type="text/javascript" src="http://b.hatena.ne.jp/js/widget.js" charset="utf-8"></script>
      <script language="javascript" type="text/javascript">
        Hatena.BookmarkWidget.url   = "http://haya14busa.com";
        Hatena.BookmarkWidget.title = "Recent Posts";
        Hatena.BookmarkWidget.sort  = "hot";
        Hatena.BookmarkWidget.width = 0;
        Hatena.BookmarkWidget.num   = 10;
        Hatena.BookmarkWidget.theme = "notheme";
        Hatena.BookmarkWidget.load();
      </script>
    </section>
  </div><!-- /div#footer-second -->

  <div id="footer-third" class="footer-widget">
    <h3>Popular Posts</h3>
    <section id="hatena-popular" class="hatena-bookmark">
      <script language="javascript" type="text/javascript" src="http://b.hatena.ne.jp/js/widget.js" charset="utf-8"></script>
      <script language="javascript" type="text/javascript">
        Hatena.BookmarkWidget.url   = "http://haya14busa.com";
        Hatena.BookmarkWidget.title = "Popular Posts";
        Hatena.BookmarkWidget.sort  = "count";
        Hatena.BookmarkWidget.width = 0;
        Hatena.BookmarkWidget.num   = 10;
        Hatena.BookmarkWidget.theme = "notheme";
        Hatena.BookmarkWidget.load();
      </script>
    </section>
  </div><!-- /div#footer-third -->
</div><!-- /div#footer-widgets-wrapper -->

<div id="credit" role="contentinfo">
  <p>
    Copyright &copy; 2016 - <a href="https://github.com/haya14busa/">haya14busa</a> -
    <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> | Themed with <a href="https://github.com/haya14busa/mjolvim-octotheme">Mjolvim</a></span>
  </p>
</div>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'haya14busa-s-memo';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>






<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id; js.async = true;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
